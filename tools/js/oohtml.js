(() => {
    function P(e) { return !Array.isArray(e) && typeof e == "object" && e } function G(e) { return typeof e } function b(e, ...t) { globalThis.WebQitInternalsRegistry || (globalThis.WebQitInternalsRegistry = new Map); var r = globalThis.WebQitInternalsRegistry.get(e); if (!r) { if (r = new Map, t[0] === !1) return r; globalThis.WebQitInternalsRegistry.set(e, r) } for (var i, s; i = t.shift();)if ((s = r) && !(r = r.get(i))) { if (r = new Map, t[0] === !1) return r; s.set(i, r) } return r } function S(e) { return Array.isArray(e) } function At(e) { return e === !0 || e === !1 } function Ye(e) { return typeof e == "function" } function Nr(e) { return Ye(e) && /^class\s?/.test(Function.prototype.toString.call(e)) } function Wt(e) { return e === null || e === "" } function ne(e) { return arguments.length && (e === void 0 || typeof e > "u") } function A(e) { return Array.isArray(e) || typeof e == "object" && e || Ye(e) } function Tr(e) { return Wt(e) || ne(e) || e === !1 || e === 0 || A(e) && !Object.keys(e).length } function I(e) { return Ye(e) || e && {}.toString.call(e) === "[object function]" } function Oe(e) { return e instanceof Number || typeof e == "number" } function Y(e) { return Oe(e) || e !== !0 && e !== !1 && e !== null && e !== "" && !isNaN(e * 1) } function zt(e) { return P(e) && Object.getPrototypeOf(e) === Object.prototype } function be(e) { return e instanceof String || typeof e == "string" && e !== null } function Fr(e) { return !be(e) && !ne(e.length) } function Ve(e, t = 1) { var r = 0; e.forEach(s => { r++ }); var i = e.slice(e.length - r, t); return arguments.length > 1 ? i : i[0] } function ae(e, t = 1) { return arguments.length > 1 ? Ve(e.slice().reverse(), t).reverse() : Ve(e.slice().reverse()) } function Qt(e, ...t) { return t.forEach(r => { e.indexOf(r) < 0 && e.push(r) }), e } function Lr(i, t) { t = t || Object.prototype, t = t && !S(t) ? [t] : t; for (var r = [], i = i; i && (!t || t.indexOf(i) < 0) && i.name !== "default";)r.push(i), i = i ? Object.getPrototypeOf(i) : null; return r } function Rr(e, t) { var r = []; return Lr(e, t).forEach(i => { Qt(r, ...Object.getOwnPropertyNames(i)) }), r } function oe(e, t, r = !1, i = !1, s = !1) { var n = 0, a = e.shift(); if ((Y(a) || a === !0 || a === !1) && (n = a, a = e.shift()), !e.length) throw new Error("_merge() requires two or more array/objects."); return e.forEach((o, u) => { !A(o) && !I(o) || (r ? Rr(o) : Object.getOwnPropertyNames(o)).forEach(c => { if (!!t(c, a, o, u)) { var h = a[c], f = o[c]; if ((S(h) && S(f) || P(h) && P(f)) && (n === !0 || n > 0)) a[c] = S(h) && S(f) ? [] : {}, oe([Y(n) ? n - 1 : n, a[c], h, f], t, r, i, s); else if (S(a) && S(o)) i ? a[c] = f : a.push(f); else try { s ? Object.defineProperty(a, c, Object.getOwnPropertyDescriptor(o, c)) : a[c] = o[c] } catch { } } }) }), a } function ue(e, t) { var r = void 0; return A(e) && Object.keys(e).forEach((i, s) => { r !== !1 && (r = t(Y(i) ? parseFloat(i) : i, e[i], s)) }), r } function le(...e) { return oe(e, (t, r, i) => !0, !1, !1, !1) } function Ht(e, t, r = !1) { if (t == "") return e; var i = r ? e.lastIndexOf(t) : e.indexOf(t); return i === -1 ? "" : e.substr(i + t.length) } function ct(e, t, r = null, i = !1) { return t.length > e.length ? -1 : (typeof r == "number" ? i ? e.slice(0, r + 1 + (r < 0 ? e.length : 0)) : e.slice(r) : e).reduce((s, n, a) => { var [o, u, c] = s; if (!i && o > -1) return [o, u, c]; var h = c + 1, f = n === t[h] ? h === 0 ? [a, 0] : [u, h] : [-1, -1]; return f[1] === t.length - 1 && (f[1] = -1, f[0] > -1) ? [f[0]].concat(f) : [o].concat(f) }, [-1, -1, -1])[0] + (i || typeof r != "number" ? 0 : r > -1 ? r : e.length - r) } function ht(e, t, r = null, i = !1) { var s = ct(e, t, r, i); return s === -1 ? [] : e.slice(s + t.length) } function De(e, t) { return e.reduce((r, i, s) => r || t(i, s), !1) } function Mr(e, t, r = !1) { if (t == "") return e; var i = r ? e.lastIndexOf(t) : e.indexOf(t); return i === -1 ? e : e.substr(0, i) } function O(e, t = !0) { return S(e) ? e : !t && P(e) ? [e] : e !== !1 && e !== 0 && Tr(e) ? [] : Fr(e) ? Array.prototype.slice.call(e) : P(e) ? Object.values(e) : [e] } function ft(e, t, r = null) { return S(t) ? e.filter(i => r ? t.filter(s => r(i, s)).length : t.indexOf(i) === -1) : [] } function Be(e, t, r = null) { return r || r !== !1 && e.dotSafe && t.dotSafe ? e.join(".") === t.join(".") : e.length === t.length && e.reduce((i, s, n) => i && s === t[n], !0) } function pt(e, t, r = !1) { for (var i = e.indexOf(t); i > -1 && (r || r === !1);)e.splice(i, 1), r > 0 && r--, i = e.indexOf(t); return e } var Ei = function (e, t = 1, r = !0) { return !Y(t) || t <= 0 || (!S(e) && P(e) && r && (e = Object.values(e)), !S(e)) ? e : e.reduce((i, s) => S(s) || P(s) && r ? i.concat(Ei(S(s) ? s : Object.values(s), t - 1, r)) : i.concat(s), []) }, Vr = Ei; function Pt(e, t, r = null) { return S(t) ? e.filter(i => r ? t.filter(s => r(i, s)).length : t.indexOf(i) !== -1) : [] } function Ot(e, t, r = null) { return r || r !== !1 && e.dotSafe && t.dotSafe ? (e.join(".") + ".").startsWith(t.join(".") + ".") : t.reduce((i, s, n) => i && s === e[n], !0) } function Xe(e) { let t = (r, i, s) => s.indexOf(r) === i; return e.filter(t) } function Ze(e) { return (Dr(e) ? e : O(e).length ? [e] : []).reduce((t, r) => t.concat([O(r)]), []).map(t => je.resolve(t)) } var je = class extends Array { static resolve(t) { return t.every(r => !(r + "").includes(".")) ? new je().concat(t) : t } get dotSafe() { return !0 } }; function Dr(e) { return O(e).reduce((t, r) => t || S(r), !1) } function Br(e) { return e.filter(t => t || t === 0).length !== e.length } function Ci(e) { return e.filter(t => Br(O(t))).length > 0 } var et = class { constructor(t) { this.target = t, this.fireables = [], this.currentlyFiring = [] } add(t) { return this.fireables.push(t), t } remove(t) { this.fireables = this.fireables.filter(r => r !== t) } removeMatches(t) { this.match(t).forEach(r => { this.fireables = this.fireables.filter(i => i !== r) }) } match(t) { return this.fireables.filter(r => { var i = Ze(r.filter), s = O((r.params || {}).tags), n = Ze(t.filter), a = O((t.params || {}).tags); return (!t.originalHandler || r.handler === t.originalHandler) && (!n.length || Be(n, i)) && (!a.length || a.length === s.length && Pt(s, a).length === a.length) }) } static _getFirebase(t, r, i = !0, s = this.__namespace) { if (!A(r)) throw new Error('Subject must be of type object; "' + G(r) + '" given!'); var n = this; return s && globalThis.WebQitObserverNamespaceRegistry.has(t + "-" + s) && (n = globalThis.WebQitObserverNamespaceRegistry.get(t + "-" + s), t += "-" + s), !b(r, "firebases").has(t) && i && b(r, "firebases").set(t, new n(r)), b(r, "firebases").get(t) } static _namespace(t, r, i = null) { if (t += "-" + r, arguments.length === 2) return globalThis.WebQitObserverNamespaceRegistry.get(t); if (!(i.prototype instanceof this)) throw new Error(`The implementation of the namespace ${this.name}.${r} must be a subclass of ${this.name}.`); globalThis.WebQitObserverNamespaceRegistry.set(t, i), i.__namespace = r } }; globalThis.WebQitObserverNamespaceRegistry || (globalThis.WebQitObserverNamespaceRegistry = new Map); var tt = class { constructor(t, r) { this.target = t, this.handler = r.handler, this.filter = r.filter, this.params = r.params } disconnect() { this.disconnected = !0 } }; var It = class extends tt { fire(t, r, i) { return this.disconnected || this.filter && !Pt(O(this.filter), [t.type]).length ? r(...Array.prototype.slice.call(arguments, 2)) : this.handler(t, i, r) } }; function mt(e, t, r = !0, i = !0, s = !1, n = !1) { if (S(e) && S(t)) { var a = [], o = !0; return e.forEach(u => { if (!!o) { var c = !1; ue(t, (h, f) => { (!c || i && A(u)) && (c = r(u, f), (S(c) && !c.length || P(c) && !Object.keys(c).length) && (c = !1), A(c) && i && (u = c)) }), A(c) ? a.push(i ? c : u) : At(c) ? s && !c || !s && c ? a.push(u) : n && (o = !1) : a.push(c) } }), a } if (P(e) && P(t)) { var a = {}, o = !0; return Object.keys(e).forEach(h => { if (!!o) { var f = r(e[h], t[h]); (S(f) && !f.length || P(f) && !Object.keys(f).length) && (f = !1), A(f) ? a[h] = i ? f : e[h] : At(f) ? s && !f || !s && f ? a[h] = e[h] : n && (o = !1) : a[h] = f } }), a } } function Gt(e, t = [], r = !0) { var i = 0; return Y(arguments[0]) && A(arguments[1]) && (i = arguments[0], e = arguments[1], t = arguments[2] || []), oe([i, {}, e], (s, n, a) => I(t) ? t(s) : S(t) && t.length ? t.indexOf(s) > -1 : !0, !1, !1, r) } function Kt(e, t = []) { return oe([{}, e], (r, i, s) => { if (!I(s[r])) return I(t) ? t(r) : S(t) && t.length ? t.indexOf(r) > -1 : !0 }, !1, !1, !1) } var jr = function (e, t, r = !0, i = 1) { if (S(e) && S(t) && e.length !== t.length) return !r; if (P(e) && P(t)) { var s = Object.keys(e), n = Object.keys(t); if (!s.length && !n.length) return zt(e) && zt(t) ? r : e === t === r; if (!jr(s, n)) return !r } if (i > 0 && (S(e) && S(t) || P(e) && P(t))) { var a = mt(e, t, (o, u) => jr(o, u, r, i - 1), !1, !1, !0); return S(a) ? a.length === e.length && a.length === t.length : P(a) && P(e) ? Object.keys(a).length === Object.keys(e).length && Object.keys(a).length === Object.keys(t).length : a } return I(r) ? r(e, t) : Oe(e) && Oe(t) && isNaN(e) && isNaN(t) ? r : e === t === r }, qr = jr; var dt = class { constructor(t, r) { if (this.target = t, !r.type) throw new Error("Action type must be given in definition!"); ue(r, (i, s) => { Object.defineProperty(this, i, { value: s, enumerable: !0 }) }), Object.seal(this) } }; var Q = class extends et { add(t) { return super.add(new It(this.target, t)) } fire(t, r = null) { if (t instanceof dt || (t = new dt(this.target, t)), this.currentlyFiring.filter(n => n.type === t.type && n.name === t.name).length) return r ? r() : void 0; this.currentlyFiring.push(t); let i = (n, ...a) => { var o = this.fireables[n]; return o ? o.fire(t, (...u) => i(n + 1, ...u), ...a) : r ? r(...a) : a[0] }; var s = i(0); return this.currentlyFiring.pop(), s } static getFirebase(t, r = !0, i = null) { return super._getFirebase("interceptor", ...arguments) } static namespace(t, r = null) { return super._namespace("interceptor", ...arguments) } }; function $(e) { return b(e, !1).get(e) || e } function H(e, t, r = {}, i = {}) { if (!t || !A(t)) throw new Error("Target must be of type object!"); t = $(t); var s, n = function (a) { return arguments.length ? a : Reflect[e](t, ...Object.values(r)) }; return (s = Q.getFirebase(t, !1, i.namespace)) ? s.fire({ type: e, ...r }, n) : n() } function Jt(e, t, r, i = {}) { return H("apply", e, { thisArgument: t, argumentsList: r }, i) } function Yt(e, t, r = null, i = {}) { return H("construct", e, arguments.length > 2 ? { argumentsList: t, newTarget: r } : { argumentsList: t }, i) } function Ur(e, t) { return Mr(e, t, !0) } function Xt(e, t, r) { return Ur(Ht(e, t), r) } function Wr(e, t, r) { return e.startsWith(t) && e.endsWith(r) } var ye = class { constructor(t, r = !1) { this._ = {}, this._.target = t, this._.cancellable = r, this._.propagationStopped = !1, this._.defaultPrevented = !1, this._.promisesInstance = null, this._.promises = [] } get target() { return this._.target } get cancellable() { return this._.cancellable } stopPropagation() { this._.propagationStopped = !0 } get propagationStopped() { return this._.propagationStopped } preventDefault() { this._.defaultPrevented = !0 } get defaultPrevented() { return this._.defaultPrevented } waitUntil(t) { t instanceof Promise && (this._.promises.push(t), this._.promisesInstance = null) } get promises() { return !this._.promisesInstance && this._.promises.length && (this._.promisesInstance = Promise.all(this._.promises)), this._.promisesInstance } respondWith(t) { var r, i = P(t) && !ne(t.propagationStopped) && !ne(t.defaultPrevented); t === !1 || i && t.propagationStopped ? this.stopPropagation() : t === !1 || i && t.defaultPrevented ? this.preventDefault() : (t instanceof Promise && (r = t) || i && (r = t.promises)) && this.waitUntil(r) } }; var Nt = class extends tt { constructor(t, r) { if (super(t, r), this.filters2D = Ze(this.filter), this.filtersIsOriginally2D = Dr(this.filter), this.filtersIsDynamic = Ci(this.filters2D), this.filtersIsDynamic && this.filters2D.length > 1) throw new Error('Only one "Dynamic Filter" must be observed at a time! "' + this.filters2D.map(i => "[" + i.join(", ") + "]").join(", ") + '" have been bound together.') } fire(t) { if (this.disconnected || this.params.type && !De(t, a => this.params.type === a.type)) return; let r = a => !["set", "def"].includes(a.type) || !this.params.diff || (I(this.params.diff) ? this.params.diff(a.value, a.oldValue) : a.value !== a.oldValue); var i = new ye(this.target); if (this.filters2D.length) { var s = t.filter(a => this.filters2D.filter((o, u) => { var c = o.slice(); return this.filtersIsDynamic && a.path.forEach((h, f) => { c[f] = c[f] || c[f] === 0 ? c[f] : h }), (!this.filtersIsDynamic || !Br(c)) && r(a) && (!this.params.subtree && Be(c, a.path) || this.params.suptree && Ot(c, a.path) && (!Y(this.params.suptree) || ht(c, a.path).length <= this.params.suptree) || this.params.subtree && a.path.length >= c.length && Ot(a.path, c) && (!Y(this.params.subtree) || ht(a.path, c).length <= this.params.subtree)) }).length); if (s.length) if (this.filtersIsOriginally2D || this.params.subtree) { var n = s; P(this.filter) && (n = { ...this.filter }, s.forEach((a, o) => { n[a.name] = a })), i.respondWith(this.handler(n, i)) } else s.forEach((a, o) => { i.respondWith(this.handler(a, i)) }) } else (this.params.subtree || t.filter(a => Be(a.path, [a.name])).length === t.length) && t.filter(a => r(a)).length && i.respondWith(this.handler(t, i)); return i } }; var qe = class { constructor(t, r) { if (this.target = t, r.originalSubject || (this.originalSubject = t), !("type" in r)) throw new Error("Mutation type must be given in definition!"); if (!("name" in r)) throw new Error("Property name must be given in definition!"); ue(r, (i, s) => { i === "path" && (s = je.resolve(s)), Object.defineProperty(this, i, { value: s, enumerable: !0 }) }), this.path || Object.defineProperty(this, "path", { value: je.resolve([r.name]), enumerable: !0 }), Object.seal(this) } }; var q = class extends et { constructor(t) { super(t), this.buffers = [] } add(t) { return super.add(new Nt(this.target, t)) } fire(t, r) { var i = new ye(this.target, r); return t = O(t, !1).map(s => s instanceof qe ? s : new qe(this.target, s)), this.buffers.length ? (ae(this.buffers)(t), i) : (this.currentlyFiring.filter(s => t.filter(n => s.type === n.type && s.name === n.name).length).length, this.fireables.forEach(s => { if (i.propagationStopped && r) return i; i.respondWith(s.fire(t)) }), i) } static getFirebase(t, r = !0, i = null) { return super._getFirebase("observer", ...arguments) } static namespace(t, r = null) { return super._namespace("observer", ...arguments) } }; function ce(e, t, r = null, i = {}) { if (e = r || e, !e || !A(e)) throw new Error("Target must be of type object!"); e = $(e); var s = O(t), n = s.map(a => { var o, u = function (c) { return arguments.length ? c : b(e, "accessorizedProps").has(a) && b(e, "accessorizedProps").get(a).touch(!0) ? b(e, "accessorizedProps").get(a).get() : r ? Reflect.get(e, a, r) : Reflect.get(e, a) }; return (o = Q.getFirebase(e, !0, i.namespace)) ? o.fire({ type: "get", name: a, related: s, receiver: r }, u) : u() }); return S(t) ? n : n[0] } function Zt(e, t, r = null, i = {}) { if (e = $(e), !e || !A(e)) throw new Error('Observable subjects must be of type object; "' + G(e) + '" given!'); if (I(t) && (i = arguments.length > 2 ? r : {}, r = t, t = null), !I(r)) throw new Error('Handler must be a function; "' + G(r) + '" given!'); var s, n = q.getFirebase(e, !0, i.namespace), a = { filter: t, handler: r, params: i }; if ((a.filter || a.params.subtree === "*" || a.params.subtree && gt(e)) && $e(e, a.filter, a.params.subtree, i.namespace), a.params.unique && (s = n.match({ filter: t, params: i })).length) { if (a.params.unique !== "replace") return s[0]; n.remove(s[0]) } return n.add(a) } function Ue(e, t, r, i = null, s = {}) { if (e !== r) { var n; if (Zt(r, (o, u) => { if (n = q.getFirebase(e, !1, s.namespace)) { var c = o.map(h => { var f = h; do if (f.target === e) return; while (f = f.src); var m = {}; return ue(h, (p, g) => { p !== "target" && p !== "name" && p !== "path" && p !== "src" && (m[p] = g) }), m.name = t, m.path = [t].concat(h.path), m.originalSubject = h.originalSubject, m.src = h, new qe(e, m) }).filter(h => h); if (c.length) return n.fire(c, u.cancellable) } }, { subtree: !0, ...s, unique: !0, tags: [zr, t, e] }), P(i) && (n = q.getFirebase(e, !1, s.namespace))) { var a = le({ name: t, type: "set", value: r, related: [t] }, i); let o = n.fire(a, s.cancellable); if (s.eventTypeReturn) return o } } } var zr = {}; function $e(e, t = null, r = !1, i = null) { if (!e || !A(e)) throw new Error("Target must be of type object!"); var s = q.getFirebase(e, !0, i); if (!(!s || s.build)) { s.build = r; var n = Ze(t), a = !n.length || n.filter(u => !u[0] && u[0] !== 0).length ? Object.keys(e) : n.map(u => u[0]), o = n.length ? n.map(u => u.slice(1)).filter(u => u.length) : null; s.subBuild = o && o.length ? o : null, a.forEach(u => { var c = ce(e, u, null, { namespace: i }); try { A(c) && (Ue(e, u, c, null, params), (s.subBuild && gt(c) || (_isFunction(r) ? r(c) : r && gt(c))) && $e(c, s.subBuild, r, i)) } catch { } }) } } var gt = e => (e instanceof Object || e instanceof Array || e instanceof Function) && (typeof window > "u" || e !== window); function er(e, t, r = null, i = {}) { if (e = $(e), !e || !A(e)) throw new Error('Observable subjects must be of type object; "' + G(e) + '" given!'); if (I(t) && (i = arguments.length > 2 ? r : {}, r = t, t = null), r && !I(r)) throw new Error('Handler must be a function; "' + G(r) + '" given!'); var s; if (s = q.getFirebase(e, !1, i.namespace)) return s.removeMatches({ filter: t, originalHandler: r, params: i }) } function We(e, t, r, i = null, s = {}) { er(r, null, null, { ...s, tags: [zr, t, e] }); var n; if (P(i) && (n = q.getFirebase(e, !1, s.namespace))) { var a = le({ name: t, type: "del", oldValue: r, related: [t] }, i); n.fire(a, s.cancellable) } } function ze(e, t, r = {}) { return H("has", e, { name: t }, r) } function tr(e, t, r, i = {}) { t = r.receiver || t; var s = r.keysOrPayload, n = r.value; if (!t || !A(t)) throw new Error("Target must be of type object!"); P(s) && (i = n || {}, n = null), t = $(t); var a = Q.getFirebase(t, !1, i.namespace), o = q.getFirebase(t, !1, i.namespace); let u = (p, g, y, x) => { var v = "set", _; e && (v = "defineProperty", _ = g || {}, g = _.value); var w = !1, k; ze(t, p, i) && (w = !0, k = ce(t, p, r.receiver, i)); var B = { name: p, type: v, value: g, receiver: r.receiver, related: y, detail: x, isUpdate: w, oldValue: k }, X = function (R) { return arguments.length && (_ ? _ = R : g = R), _ ? b(t, "accessorizedProps", !1).has(p) && !b(t, "accessorizedProps").get(p).restore() ? !1 : (Object.defineProperty(t, p, _), !0) : b(t, "accessorizedProps", !1).has(p) ? b(t, "accessorizedProps").get(p).set(g) : (t[p] = g, !0) }; if (a) { var Je = _ ? { type: "defineProperty", name: p, descriptor: _, receiver: r.receiver, related: y, detail: x, isUpdate: w, oldValue: k } : { type: "set", name: p, value: g, receiver: r.receiver, related: y, detail: x, isUpdate: w, oldValue: k }; B.success = a.fire(Je, X) } else B.success = X(); return B.success && B.value !== B.oldValue && (A(B.oldValue) && We(t, p, B.oldValue, null, i), A(B.value) && (Ue(t, p, B.value, null, i), o && (o.subBuild || o.build && gt(B.value)) && $e(B.value, o.subBuild, o.build, i.namespace))), B }; var c, h = []; S(s) || (be(s) || Oe(s)) && (c = O(s)) ? h = c.map(p => u(p, n, c, i.detail)) : P(s) && (c = Object.keys(s)) && (h = c.map(p => u(p, s[p], c, i.detail))); var f = h.filter(p => p.success !== !1), m; return o ? (m = o.fire(f, i.cancellable), m.successCount = f.length) : i.eventTypeReturn && (m = new ye(t)), i.eventTypeReturn ? m : f.length > 0 } function rr(e, t, r = null, i = {}) { return tr(!0, e, { keysOrPayload: t, value: r }, i) } function ir(e, t, r = {}) { if (!e || !A(e)) throw new Error("Target must be of type object!"); e = $(e); var i = O(t), s = i.map(u => { var c; ze(e, u, r) && (c = ce(e, u, null, r)); var h = { name: u, type: "deleteProperty", related: i, detail: r.detail, oldValue: c }, f, m = function (p) { return arguments.length ? p : b(e, "accessorizedProps", !1).has(u) && !b(e, "accessorizedProps").get(u).restore() ? !1 : (delete e[u], !0) }; return (f = Q.getFirebase(e, !1, r.namespace)) ? h.success = f.fire({ type: "deleteProperty", name: u, oldValue: c, related: i }, m) : h.success = m(), h.success && A(h.oldValue) && We(e, u, h.oldValue, null, r), h }), n = s.filter(u => u.success !== !1), a, o; return (a = q.getFirebase(e, !1, r.namespace)) ? (o = a.fire(n, r.cancellable), o.successCount = n.length) : r.eventTypeReturn && (o = new ye(e)), r.eventTypeReturn ? o : n.length > 0 } function sr(e, t, r = {}) { return H("getOwnPropertyDescriptor", e, { name: t }, r) } function nr(e, t = {}) { return H("getPrototypeOf", e, {}, t) } function ar(e, t = {}) { return H("isExtensible", e, {}, t) } function or(e, t = {}) { return H("ownKeys", e, {}, t) } function ur(e, t = {}) { return H("preventExtensions", e, {}, t) } function xt(e, t, r = null, i = null, s = {}) { return tr(!1, e, arguments.length > 3 ? { keysOrPayload: t, value: r, receiver: i } : { keysOrPayload: t, value: r }, s) } function lr(e, t, r = {}) { return H("setPrototypeOf", e, { prototype: t }, r) } function ki(e, t = [], r = {}) { r = P(t) ? t : r; var i = (arguments.length === 1 ? Object.keys(e) : O(t)).map(s => { if (b(e, "accessorizedProps").has(s) && b(e, "accessorizedProps").get(s).touch(!0)) return !1; let n = () => { for (var m, p = e; !m && (p = Object.getPrototypeOf(p));)m = Object.getOwnPropertyDescriptor(p, s); return m }; var a = Object.getOwnPropertyDescriptor(e, s), o, u; a || (o = { writable: !0, enumerable: !(s in e), configurable: r.configurable !== !1 }); var c = { ...a || o }; "value" in c && delete c.value, "writable" in c && delete c.writable, c.get = () => { if (f.ongoingGets.length) return f.get(); f.ongoingGets.push(1); var m = ce(e, s, null, r); return f.ongoingGets.pop(), m }; var h; c.set = m => { if (f.ongoingSets.length) return f.set(m); f.ongoingSets.push(1); var p = xt(e, s, m, null, r); return f.ongoingSets.pop(), p }; var f = { ongoingGets: [], ongoingSets: [], get: function () { var m = a; return m || (u ? m = o : m = n() || o), m.get ? m.get.call(e) : m.value }, set: function (m) { var p = a; return p || (u ? p = o : (p = n()) ? "value" in p && (p = o, u = !0) : (p = o, u = !0)), p.set || p.get ? p.set ? p.set.call(e, m) : !1 : (p.value = m, !0) }, restore: function () { try { return this.intact() && (a || u ? Object.defineProperty(e, s, a || o) : delete e[s], b(e, "accessorizedProps").delete(s)), !0 } catch { } return !1 }, intact: function () { return (Object.getOwnPropertyDescriptor(e, s) || {}).get === c.get }, touch: function (m = !1) { return this.intact() || (m ? !this.restore() : !1) } }; try { return Object.defineProperty(e, s, c), b(e, "accessorizedProps").set(s, f), !0 } catch { } return !1 }); return S(t) ? i : i[0] } function Ai(e, t = [], r = {}) { r = P(t) ? t : r; var i = (arguments.length === 1 ? Object.keys(e) : O(t)).map(s => b(e, "accessorizedProps", !1).has(s) ? b(e, "accessorizedProps").get(s).restore() : !0); return S(t) ? i : i[0] } function Pi(e, t = {}) { if (!A(e)) throw new Error('Object must be of type target; "' + G(e) + '" given!'); var r = new Proxy(e, { apply: (i, s, n) => Jt(i, s, n, t), construct: (i, s, n = null) => Yt(i, s, n, t), defineProperty: (i, s, n) => rr(i, s, n, t), deleteProperty: (i, s) => ir(i, s, t), get: (i, s, n = null) => { var a = ce(i, s, n, t); return t.proxyAutoBinding !== !1 && I(a) && !Nr(a) ? a.bind(r) : a }, getOwnPropertyDescriptor: (i, s) => sr(i, s, t), getPrototypeOf: i => nr(i, t), has: (i, s) => ze(i, s, t), isExtensible: i => ar(i, t), ownKeys: i => or(i, t), preventExtensions: i => ur(i, t), set: (i, s, n, a = null) => xt(i, s, n, a, t), setPrototypeOf: (i, s) => lr(i, s, t) }); return b(r).set(r, e), r } function Oi(e, t, r = {}) { if (e = $(e), !A(e)) throw new Error('Object must be of type target; "' + G(handler) + '" given!'); var i = {}, s = !0; P(t) || (I(t) ? t = { "": t } : I(r) && (t = { [t]: r }, r = arguments.length > 3 ? arguments[3] : {}), s = !1); var n = Q.getFirebase(e, !0, r.namespace); return Object.keys(t).forEach(a => { if (!I(t[a])) throw new Error("Callback" + (a === null ? "" : " for " + a) + ' must be a function; "' + G(t[a]) + '" given!'); var o = { filter: a, handler: t[a], params: r }, u; if (o.params.unique && (u = n.match(o)).length) { if (o.params.unique !== "replace") return u[0]; n.remove(u[0]) } s ? i[a] = n.add(o) : i = n.add(o) }), i } function Ii(e, t = null, r = {}) { if (e = $(e), !e || !A(e)) throw new Error('Object must be of type target; "' + G(e) + '" given!'); var i = Q.getFirebase(e, !1, r.namespace); _isObject(t) || (I(t) ? t = { [null]: t } : I(r) && (t = { [t]: r }, r = arguments.length > 3 ? arguments[3] : {}), isOriginallyObj = !1), (i = Q.getFirebase(e, !1, r.namespace)) && Object.keys(t).forEach(s => { if (!I(t[s])) throw new Error("Callback" + (s === null ? "" : " for " + s) + ' must be a function; "' + G(t[s]) + '" given!'); var n = { filter: s, originalHandler: t[s], params: r }; return i.removeMatches(n) }) } function Ni(e, ...t) { var r = t.map(n => { if (n = $(n), !A(n)) throw new Error("Target must be of type object!"); return { target: n, subjectCopy: S(n) ? n.slice(0) : Gt(n) } }), i = e(...t); let s = () => { r.map(n => { var a = Object.keys(n.subjectCopy), o = Object.keys(n.target), u = [], c = Xe(a.concat(o)).map(f => { if (n.subjectCopy[f] !== n.target[f]) { u.push(f); var m = { name: f, related: u, buffered: !0 }; return o.includes(f) ? (m.type = "set", m.value = n.target[f], a.includes(f) && (m.isUpdate = !0)) : m.type = "del", a.includes(f) && (m.oldValue = n.subjectCopy[f]), A(n.subjectCopy[f]) && We(n.target, f, n.subjectCopy[f]), A(n.target[f]) && Ue(n.target, f, n.target[f]), m } }).filter(f => f), h; if (c.length && (h = q.getFirebase(n.target, !1))) return h.fire(c) }) }; return i instanceof Promise ? i.then(s) : s(), i } var U = { apply: Jt, construct: Yt, defineProperty: rr, deleteProperty: ir, get: ce, getOwnPropertyDescriptor: sr, getPrototypeOf: nr, has: ze, isExtensible: ar, ownKeys: or, preventExtensions: ur, set: xt, setPrototypeOf: lr, accessorize: ki, unaccessorize: Ai, proxy: Pi, unproxy: $, observe: Zt, unobserve: er, intercept: Oi, unintercept: Ii, closure: Ni, build: $e, link: Ue, unlink: We, Observers: q, Interceptors: Q }; function ve(e) { return !Array.isArray(e) && typeof e == "object" && e } function Ti(e) { var t = typeof e.InstallTrigger < "u"; if (t) return "firefox"; var r = /constructor/i.test(e.HTMLElement) || function (c) { return c.toString() === "[object SafariRemoteNotification]" }(!e.safari || typeof e.safari < "u" && e.safari.pushNotification); if (r) return "safari"; var i = !!e.chrome && (!!e.chrome.webstore || !!e.chrome.runtime), s = i && e.navigator.userAgent.indexOf("Edg") != -1, n = !!e.opr && !!e.opr.addons || !!e.opera || e.navigator.userAgent.indexOf(" OPR/") >= 0, a = !!e.document.documentMode, o = !a && !!e.StyleMedia, u = (i || n) && !!e.CSS; return o ? "edge" : a ? "ie" : n ? "opera" : s ? "ie-chromium" : i ? "chrome" : "unknown" } function Fi(e) { var t = e.getComputedStyle(e.document.documentElement, ""), r = (Array.prototype.slice.call(t).join("").match(/-(moz|webkit|ms)-/) || t.Olink === "" && ["", "o"])[1], i = ("WebKit|Moz|Ms|O".match(new RegExp("(" + r + ")", "i")) || [])[1]; return { api: i, prefix: r, css: "-" + r + "-" } } function Ie() { if (!(ve(this) && this.window) && typeof window > "u") throw new Error("A window context is required."); let e = ve(this) && this.window ? this.window : window; if (e.WebQit || (e.WebQit = {}), !e.WebQit.window) { let t, r; Object.defineProperty(e.WebQit, "window", { get: () => e }), Object.defineProperty(e.WebQit, "vendor", { value: { getName: () => (t || (t = Ti(e)), t), getPrefix: () => (r || (r = Fi(e)), r) } }) } return e.WebQit } function cr(e) { return typeof e == "function" } function he(e) { return Array.isArray(e) || typeof e == "object" && e || cr(e) } function Li(e) { return e instanceof Number || typeof e == "number" } function rt(e) { return Li(e) || e !== !0 && e !== !1 && e !== null && e !== "" && !isNaN(e * 1) } var Tt = class { constructor(t, r = !0) { this.window = t, this.async = r, this.readCallbacks = [], this.writeCallbacks = [], this._run() } _run() { this.window.requestAnimationFrame(() => { this.readCallbacks.forEach((t, r) => { t && !t() && (this.readCallbacks[r] = null) }), this.writeCallbacks.forEach((t, r) => { t && !t() && (this.writeCallbacks[r] = null) }), this._run() }) } onread(t, r = !1) { if (r) return new Promise((i, s) => { this.async === !1 ? t(i, s) : this.readCallbacks.push(() => { t(i, s) }) }); this.async === !1 ? t() : this.readCallbacks.push(t) } onwrite(t, r = !1) { if (r) return new Promise((i, s) => { this.async === !1 ? t(i, s) : this.writeCallbacks.push(() => { t(i, s) }) }); this.async === !1 ? t() : this.writeCallbacks.push(t) } cycle(t, r, i) { this.onread(() => { var s = t(i); if (s) { var n = a => { this.onwrite(() => { var o = r(a, i); if (o) { var u = c => { this.cycle(t, r, c) }; o instanceof Promise ? o.then(u) : u() } }) }; s instanceof Promise ? s.then(n) : n() } }) } }; function Ne(e) { return e instanceof String || typeof e == "string" && e !== null } function it(e) { return Array.isArray(e) } function bt(e) { return arguments.length && (e === void 0 || typeof e > "u") } function Ri(e) { return !Ne(e) && !bt(e.length) } function hr(e) { return e === null || e === "" } function Mi(e) { return hr(e) || bt(e) || e === !1 || e === 0 || he(e) && !Object.keys(e).length } function K(e, t = !0) { return it(e) ? e : !t && ve(e) ? [e] : e !== !1 && e !== 0 && Mi(e) ? [] : Ri(e) ? Array.prototype.slice.call(e) : ve(e) ? Object.values(e) : [e] } function Ft(e) { let t = Ie.call(this); t.DOM.isDOMReady || t.window.document.readyState === "complete" ? e(t.window) : (t.window.domReadyCallbacks || (t.window.domReadyCallbacks = [], t.window.document.addEventListener("DOMContentLoaded", () => { t.DOM.isDOMReady = !0, t.window.domReadyCallbacks.splice(0).forEach(r => r(t.window)) }, !1)), t.window.domReadyCallbacks.push(e)) } var Lt = class { constructor(t) { this.window = t } onAdded(t, r, i = {}) { return i.on = "added", this.onPresenceChange(t, (s, n, a, o, u) => { r(s, n, a, o, u) }, i) } onRemoved(t, r, i = {}) { return i.on = "removed", this.onPresenceChange(t, (s, n, a, o, u) => { r(s, n, a, o, u) }, i) } onPresent(t, r, i = {}) { Ft.call(this.window, () => { this.window.MutationObserver && this.onAdded(t, (s, n) => { s.forEach(a => r(a, n)) }, i), Ne(t) ? K(this.window.document.querySelectorAll(t)).forEach(s => r(s, 1)) : t.parentNode && r(t, 1) }) } onAbsent(t, r, i = {}) { Ft.call(this.window, () => { this.window.MutationObserver && onRemoved(t, (s, n) => { s.forEach(a => r(a, n)) }, i), Ne(t) ? K(this.window.document.querySelectorAll(t)).length === 0 && r(null, 0) : t.parentNode || r(t, 0) }) } onPresenceChange(t, r, i = {}) { t = K(t, !1); var s = (f, m) => { if (m = m.filter(y => y.matches), Ne(f)) { var p = m.filter(y => y.matches(f)); if (i.observeIndirectMutation !== !1 && (p = m.reduce((y, x) => y.concat(K(x.querySelectorAll(f))), p), p.length)) return p } else { if (m.includes(f)) return [f]; if (i.observeIndirectMutation !== !1 && m.length) { for (var g = f; g = g.parentNode;)if (m.includes(g)) return [f] } } }, n = (f, m) => (m.$$searchCache || (m.$$searchCache = new Map), f.reduce((p, g) => { var y; return m.$$searchCache.has(g) ? y = m.$$searchCache.get(g) : (y = s(g, m, Ne(g)) || [], m.$$searchCache.set(g, y)), p.concat(y) }, [])), a = new Set, o = new Set, u = (f, m, p) => { m && i.on === "removed" || !m && i.on === "added" || (f = n(t, f)).length && (i.maintainCallState ? (f.forEach(g => { m ? (a.add(g), o.delete(g)) : (a.delete(g), o.add(g)) }), r(f, m, p, a, o)) : r(f, m, p)) }, c = i.context || this.window.document.documentElement, h = this._observe(c, (f, m, p, g) => { i.ignoreTransients || (u(f, 0, !0), u(f.concat(m), 1, !0), u(m, 0, !0)), u(g, 0), u(p, 1) }); return h } onAttrChange(t, r, i = []) { var s = new this.window.MutationObserver(r), n = { attributes: !0, attributeOldValue: !0 }; return i && (n.attributeFilter = i), s.observe(t, n), s } onTreeChange(t, r, i = !1) { var s = new this.window.MutationObserver(r), n = { childList: !0, subtree: i }; return s.observe(t, n), s } onMutation(t, r, i) { var s = new this.window.MutationObserver(r); return s.observe(t, i), s } _observe(t, r) { if (!Qr.has(t)) { let s = new Set, n = new this.window.MutationObserver(a => { if (!!s.size) { var o = a.reduce((f, m) => f.concat(K(m.addedNodes)), []), u = a.reduce((f, m) => f.concat(K(m.removedNodes)), []), c = [], h = []; o = new Set(o), u = new Set(u), o.forEach(f => { u.has(f) && (u.delete(f), o.delete(f), f.isConnected ? c.push(f) : h.push(f)) }), o = [...o], u = [...u], s.forEach(f => f(c, h, o, u)) } }); n.observe(t, { childList: !0, subtree: !0 }), Qr.set(t, { callbacks: s, observer: n }) } let i = Qr.get(t); return i.callbacks.add(r), { disconnect() { i.callbacks.delete(r) }, reconnect() { i.callbacks.add(r) } } } }, Qr = new Map; function Vi(e) { Ks(e), Js(e), Ys(e) } function Ks(e) { e.CSS || (e.CSS = {}), e.CSS.escape || (e.CSS.escape = t => t.replace(/([\:@\~\$\&])/g, "\\$1")) } function Js(e) { "isConnected" in e.Node.prototype || Object.defineProperty(e.Node.prototype, "isConnected", { get: function () { return !this.ownerDocument || !(this.ownerDocument.compareDocumentPosition(this) & this.DOCUMENT_POSITION_DISCONNECTED) } }) } function Ys(e) { e.Element.prototype.matches || (e.Element.prototype.matches = e.Element.prototype.matchesSelector || e.Element.prototype.mozMatchesSelector || e.Element.prototype.msMatchesSelector || e.Element.prototype.oMatchesSelector || e.Element.prototype.webkitMatchesSelector || function (t) { for (var r = (this.document || this.ownerDocument).querySelectorAll(t), i = r.length; --i >= 0 && r.item(i) !== this;); return i > -1 }) } function fr(e, t = null, r = !1) { let i = Ie.call(this); if (Ne(e)) { var s; if (e.trim().startsWith("<")) { var n = i.window.document.createElement("div"); n.innerHTML = e, s = r ? K(n.children) : n.firstChild } else s = r ? K(Bi.call(this, e, t)) : Hr.call(this, e, t); return s } return e instanceof i.window.Element ? r ? [e] : e : r ? K(e) : e } function Di(e, t = null) { return fr.call(this, e, t, !0) } function Hr(e, t = null, r = !1) { let i = Ie.call(this); t = t || i.window.document; var s, n = r ? "querySelectorAll" : "querySelector"; try { s = t[n](e) } catch { try { s = t[n](e.replace(/\:is\(/g, ":matches(")) } catch { try { s = t[n](e.replace(/\:is\(/g, ":-webkit-any(")) } catch { try { s = t[n](e.replace(/\:is\(/g, ":-moz-any(")) } catch (c) { throw c } } } } return s } function Bi(e, t = null) { return Hr.call(this, e, t, !0) } function st(e) { return cr(e) || e && {}.toString.call(e) === "[object function]" } function Qe(e, t, r = {}, i = {}) { t = K(t).slice(); for (var s = e; !bt(s) && !hr(s) && t.length;) { var n = t.shift(); if (!(r.get ? r.get(s, n) : he(s) ? n in s : s[n])) { i.exists = !1; return } s = r.get ? r.get(s, n) : s[n] } return i.exists = !0, s } function pr(e, t, r, i = {}, s = {}) { let n = (h, f, m) => s.set ? s.set(h, f, m) : (rt(t[o]) && it(h) ? h.push(m) : h[f] = m, !0); t = K(t); for (var a = e, o = 0; o < t.length; o++)if (o < t.length - 1) { if (!a || !he(a) && !st(a)) return !1; var u = Qe(a, t[o], s); if (!he(u)) { if (s.buildTree === !1) return !1; u = st(s.buildTree) ? s.buildTree(o) : rt(t[o + 1]) ? [] : {}; var c = n(a, t[o], u); if (!c) return !1 } a = u } else return n(a, t[o], r) } function ji(e, t, r = !1, i = {}) { t = K(t); var s = !1; do { var n = t.pop(), n = n === "" ? 0 : n, a = e; t.length && (a = Qe(e, t, {}, i)), (he(a) || st(a)) && (i.has ? i.has(a, n) : n in a) && (i.deleteProperty ? s = i.deleteProperty(a, n) : i.del ? s = i.del(a, n) : (delete a[n], s = !0)) } while (s && r && t.length && (he(a) || st(a)) && !(i.keys ? i.keys(a) : Object.keys(a)).length); return s } function Gr(e, t, r = {}) { var i = {}; return Qe(e, t, r, i), i.exists } function Kr(e, t = !1) { let r = Ie.call(this); var i = {}; return !(i.el = r.window.document.head.querySelector('meta[name="oohtml"]')) && t && (i.el = r.window.document.createElement("meta"), i.el.setAttribute("name", e), r.window.document.head.append(i.el)), i.el && (i.vars = (i.el.getAttribute("content") || "").split(";").filter(s => s).reduce((s, n) => { var a = n.split("=").map(o => o.trim()); return pr(s, a[0].split("."), a[1] === "true" ? !0 : a[1] === "false" ? !1 : rt(a[1]) ? parseInt(a[1]) : a[1]), s }, {})), i.get = function (s) { return Qe(this.vars, s.split(".")) }, i.set = function (s, n = null, a = !1) { var o = ve(s) ? s : { [s]: n === !0 ? "true" : n }; if (a = arguments.length < 3 ? n : a, Object.keys(o).forEach(u => { if (o[u] === !1) ji(this.vars, u.split(".")); else if (ve(o[u])) Object.keys(o[u]).forEach(h => { var f = (u + "." + h).split("."); (!a || !Gr(this.vars, f)) && pr(this.vars, f, o[u][h]) }); else { var c = u.split("."); (!a || !Gr(this.vars, c)) && pr(this.vars, c, o[u]) } }), t) { let u = (c, h) => Object.keys(h).reduce((f, m) => { var p = (c ? c + "." : "") + m; return ve(h[m]) ? f.push(...u(p, h[m])) : f.push(p + "=" + h[m]), f }, []); this.el.setAttribute("content", u("", this.vars).join(";")) } return !0 }, i.defaults = function (s, n = null) { return this.set(s, n, !0) }, i } function ie() { let e = Ie.call(this); return e.DOM || (e.DOM = {}, Vi(e.window), e.DOM.reflow = new Tt(e.window), e.DOM.mutations = new Lt(e.window), e.DOM.meta = Kr.bind(e.window), e.DOM.query = fr.bind(e.window), e.DOM.queryAll = Di.bind(e.window), e.DOM.ready = Ft.bind(e.window)), e } var M = class { static lex(t, r, i = {}) { if (!be(t = t + "")) throw new Error("Argument1 must be a string!"); var s = c => ({ delims: c.delims.slice(), options: Kt(c.options), nesting: c.nesting.slice(), maxDepth: c.maxDepth, comments: c.comments.slice(), tokens: c.tokens.slice(), matches: c.matches.slice(), matchesi: Kt(c.matchesi) }); if (M.$cache[t] && i.cache !== !1) for (var n = 0; n < M.$cache[t].length; n++) { var a = M.$cache[t][n]; if (qr(a.delims, r)) return s(a) } var o = new M(t, i), u = o.lex(r); return i.cache !== !1 && (M.$cache[t] = M.$cache[t] || [], M.$cache[t].push(u)), s(u) } static split(t, r, i) { return M.lex(t, r, i).tokens } static match(t, r, i) { return M.lex(t, r, i).matches } constructor(t, r) { if (!be(t)) throw new Error("Lexer requires the first argument to be a string."); this.$str = t, this.$options = r || {}, this.$options.blocks || (this.$options.blocks = M.$blocks), this.$options.quotes || (this.$options.quotes = M.$quotes), this.$options.comments || (this.$options.comments = M.$comments) } lex(t, r) { for (var i = { delims: O(t), options: le(!0, {}, this.$options, r || {}), nesting: [], maxDepth: 0, comments: [], tokens: [], matches: [], matchesi: {} }, s = 0; typeof s == "number";)s = this._evalCharsAt(i, s); if (i.nesting.length) throw new Error("Error parsing the string: " + this.$str + ". Unterminated blocks: " + Vr(i.nesting).join(", ")); return i } _evalCharsAt(t, r) { if (!(r >= this.$str.length)) { var i = 1, s = {}, n = {}, a = {}; if (t.openComment || (n = this._testQuotes(t, r)), t.openQuote || (s = this._testComments(t, r)), t.openComment || s.ending) if (!t.nesting.length && !a.ending) { var o = s.starting || s.ending || this.$str[r]; i = o.length, this._push(t, o, "comments", s.starting) } else this._push(t, this.$str[r]); else if (t.openQuote || n.ending) this._push(t, this.$str[r]); else { if (t.options.limit && t.matches.length === t.options.limit) return this._push(t, this.$str[r]), r + 1; a = this._testNesting(t, r); var a = this._testNesting(t, r), u = this._testChars(t.options.stopChars || [], t, r); if (!t.nesting.length && u !== !1) { t.options.stopChar = u, t.options.stopCharForward = this.$str.substr(r); return } if (!t.delims.length) t.nesting.length === 2 && a.starting ? (t.matches.push(null), this._push(t, a.starting), i = a.starting.length) : !t.nesting.length && a.ending ? (this._push(t, a.ending), i = a.ending.length, t.matches.push(null)) : this._push(t, this.$str[r]); else if (!t.nesting.length && !a.ending) { this._push(t, ""); var c = this._testChars(t.delims, t, r); if (c !== !1 && (t.matches.push(c), t.matchesi[r] = c, i = c.length || 1, !t.options.preserveDelims)) { var h = r + (c.length || 1); return h === this.$str.length && this._push(t, ""), h } this._push(t, c || this.$str[r]) } else { var o = a.starting || a.ending || this.$str[r]; i = o.length, this._push(t, o) } } return r + i } } _testQuotes(t, r) { var i = {}; return (t.options.quotes || []).forEach(s => { this.$str.substr(r, 1) === s && (t.openQuote ? s === t.openQuote && (t.openQuote = !1, i.ending = s) : (t.openQuote = s, i.starting = s)) }), i } _testComments(t, r) { var i = {}; return (t.options.comments || []).forEach(s => { if (t.openComment) { if (ae(s) === ae(t.openComment)) { var a = ae(s); this.$str.substr(r).startsWith(a) && (t.openComment = !1, i.ending = a) } } else { var n = Ve(s); this.$str.substr(r).startsWith(n) && (t.openComment = s, i.starting = n) } }), i } _testNesting(t, r) { var i = {}; return (t.options.blocks || []).forEach(s => { var n = Ve(s); if (this.$str.substr(r).startsWith(n)) t.nesting = t.nesting.concat([s]), i.starting = n; else if (t.nesting.length && ae(s) === ae(ae(t.nesting))) { var a = ae(s); this.$str.substr(r).startsWith(a) && (t.nesting = t.nesting.slice(0, -1), i.ending = a) } }), t.maxDepth = Math.max(t.maxDepth, t.nesting.length), i } _testChars(t, r, i) { for (var s = 0; s < t.length; s++) { var n = t[s]; if (I(n)) { var a = n(this.$str.substr(0, i), this.$str.substr(i), r.tokens.slice()); if (a !== !1) return a } if (r.options.useRegex) { var o = this.$str.substr(i).match(new RegExp("^" + n, r.options.useRegex !== !0 ? r.options.useRegex : "")); if (o) return o[0] } if (!r.options.ci && this.$str.substr(i, n.length) === n || r.options.ci && this.$str.substr(i, n.length).toLowerCase() === n.toLowerCase()) return n } return !1 } _push(t, r, i = "tokens", s = !1) { var n = t.matches.length; if (ne(t.tokens[n]) && (t.tokens[n] = ""), i === "comments") { t.tokens[n].comments || (t.tokens[n] = new String(t.tokens[n]), t.tokens[n].comments = []); var a = t.tokens[n].comments.length - (!t.tokens[n].comments.length || s ? 0 : 1); t.tokens[n].comments[a] = (t.tokens[n].comments[a] || "") + r } else { var o = t.tokens[n].comments; t.tokens[n] = t.tokens[n] + r } } split(t, r, i) { return this.lex(r, i).tokens } match(t, r, i) { return this.lex(r, i).matches } regParse(t, r) { return this.lex(t, le({ useRegex: !0 }, r || {})) } regSplit(t, r) { return this.regParse(t, r).tokens } regMatch(t, r) { return this.regParse(t, r).matches } }; M.$blocks = [["(", ")"], ["[", "]"], ["{", "}"]]; M.$quotes = ['"', "'", "`"]; M.$comments = [["/*", "*/"], ["//", `
`]]; M.$cache = Object.create(null); function Ee(e, t = {}) { let r = ie.call(this); return r.OOHTML || (r.OOHTML = {}), r.OOHTML.meta || (r.OOHTML.meta = r.DOM.meta("oohtml", !0)), r.OOHTML.meta.defaults(le(3, e, t)), r.OOHTML.meta } function mr(e, t, r, i = null) { var s = t.split("#")[0].split("/").map(n => n.trim()).filter(n => n); return Ui(e, s, r, i) } function dr(e) { var t = M.split(e.trim(), [":"]); e = t.shift(); var r = t.reduce((i, s) => { var [n, a] = M.split(s.trim(), []); return i[n] = Xt(a, "(", ")"), i }, {}); return [e, r] } function $i(e, t) { return t = t.split("#")[0].split("/").map(r => r.trim()).filter(r => r), e = e.split("#")[0].split("/").map(r => r.trim()).filter(r => r), e.length ? e.reduce((r, i, s) => r ? M.split(i.trim(), ["|", "+"]).reduce((n, o) => { var [o, u] = dr(o); o = o.trim(); var c = o === t[s]; if (!c && ("deep" in u || "deepest" in u)) { var h = t.slice(s + 1).reduce((m, p, g) => m > -1 && "deep" in u ? m : p === o ? g : m, -1); if (h > -1) { var f = t.splice(s, h + 1); c = !0 } } return n || c }, !1) : !1, !0) : !1 } var qi = (e, t) => M.split(e.trim(), ["|", "+"], { preserveDelims: !0 }).reduce((r, i) => { var s; return (i.startsWith("|") || i.startsWith("+")) && (s = i.substr(0, 1), i = i.substr(1).trim()), r.theEnd || s === "|" && r.length ? (r.theEnd = !0, r) : r.concat(t(i.trim())) }, []).filter(r => r), Jr = (e, t, r) => { let i = s => s.reduce((n, a) => n.concat(...r(a).values()), []); return qi(t, n => { var [n, a] = dr(n); return e.reduce((o, u) => { var c = r(u); n === "*" && (n = "(" + c.keys().join("+") + ")"); var h = Wr(n, "(", ")") ? Jr([u], Xt(n, "(", ")"), r) : O(c.get(n), !1), f = [], m = p => `${p}${f.map(g => `:${g}(${a[g]})`).join("")}`; return Object.keys(a).forEach(p => { if (p === "deep" || p === "deepest") for (var g = [u]; (p === "deepest" || !h.length) && (g = i(g)).length;) { var y = Jr(g, m(n), r); y.length && (h = y) } else (p === "having" || p === "not-having") && (h = h.filter(x => { var v = qi(a[p], _ => r(x, _)); return p === "not-having" ? !v.length : v.length })), f.push(p) }), o.concat(h) }, []) }) }, Ui = function (e, t, r, i = null, s = 0) { if (!t.length) return []; let n = t.shift(), a; n.endsWith(".") && (a = !0, n = n.substr(0, n.length - 1).trim()); let o = Jr(e, n, r); if (o.forEach(u => { b(u, "oohtml").has("queryCallback") && b(u, "oohtml").get("queryCallback")() }), o.length && a) return o; if (t.length) { let u = Ui(o, t.slice(), r, i, s + 1); return u === -1 ? i(o, s, !0) : u } return i ? i(o, s) : o }; function gr(e = {}) { let t = ie.call(this); if (e.onDomReady) { t.DOM.ready(() => { gr.call(this, { ...e, onDomReady: !1 }) }); return } let r = t.window, i = t.window.document, s = t.DOM.mutations, n = Ee.call(this, { element: { template: "", export: "export", import: "import" }, attr: { moduleid: "name", moduleref: "template", exportid: "name", exportgroup: "exportgroup" }, api: { templateClass: "", templates: "templates", exports: "exports", moduleref: "template" } }, e.params), a = "template" + (n.get("element.template") ? '[is="' + n.get("element.template") + '"]' : "") + "[" + r.CSS.escape(n.get("attr.moduleid")) + "]"; var o = r.HTMLTemplateElement; if (n.get("api.templateClass")) { if (!r[n.get("api.templateClass")]) throw new Error('The custom element class "' + n.get("api.templateClass") + '" is not defined!'); o = r[n.get("api.templateClass")] } let u = (x, v, _) => { x === "templatemutation" && (["addedExports", "removedExports"].forEach(w => { Object.defineProperty(v, w, { value: Object.keys(v[w]).map(k => ({ name: k, items: v[w][k] })) }) }), ["addedTemplates", "removedTemplates"].forEach(w => { Object.defineProperty(v, w, { value: Object.keys(v[w]).map(k => ({ name: k, item: v[w][k] })) }) })), Object.defineProperty(v, "path", { value: _ }), i.dispatchEvent(new r.CustomEvent(x, { detail: v })) }, c = (x, v) => { let _ = k => { x.dispatchEvent(new r.CustomEvent(k, { detail: { path: v } })) }; var w = x.getAttribute("src"); return new Promise((k, B) => { r.fetch ? r.fetch(w).then(X => X.ok ? X.text() : Promise.reject(X.statusText)).then(X => { x.innerHTML = X, _("load"), u("templatecontentloaded", { template: x }, v), k(x) }).catch(X => { console.error("Error fetching the bundle at " + w + ". (" + X + ")"), x.innerHTML = "", _("loaderror"), u("templatecontentloaderror", { template: x }, v), k(x) }) : (k(), console.error("Error fetching the bundle at " + w + ". (window.fetch() not supported by browser.)")) }) }, h = (x, v, _, w = null, k = !0) => { let B = (R, j, xe, Z) => { if (!!R.matches) { var z, Me; if (R.matches(a) && (z = R.getAttribute(n.get("attr.moduleid"))) && p(z)) { var Ut = (_ ? _ + "/" : "") + z; xe === "removed" ? (b(x, "oohtml", "templates").delete(z), b(R, "oohtml").get("parentTemplate") === x && b(R, "oohtml").delete("parentTemplate"), j && (j.removedTemplates[z] = R)) : xe === "added" && (b(x, "oohtml", "templates").set(z, R), b(R, "oohtml").set("parentTemplate", x), j && (j.addedTemplates[z] = R)), h(R, R.content, Ut, xe, Z) } else { let vi = kt => { var J = kt.getAttribute(n.get("attr.exportgroup")) || "default"; xe === "removed" ? b(x, "oohtml", "exports").has(J) && (pt(b(x, "oohtml", "exports").get(J), kt), b(x, "oohtml", "exports").has(J).length || b(x, "oohtml", "exports").delete(J), j && (j.removedExports[J] || (j.removedExports[J] = []), j.removedExports[J].push(kt))) : xe === "added" && (b(x, "oohtml", "exports").has(J) || b(x, "oohtml", "exports").set(J, []), b(x, "oohtml", "exports").get(J).push(kt), j && (j.addedExports[J] || (j.addedExports[J] = []), j.addedExports[J].push(kt))) }; if (R.matches(n.get("element.export"))) { var Me = R.getAttribute(n.get("attr.exportid")) || "default"; O(R.children).forEach(J => { J.setAttribute(n.get("attr.exportgroup"), Me), vi(J) }) } else vi(R) } } }; x.modulemutationsType = w; let X = { addedTemplates: Object.create(null), removedTemplates: Object.create(null), addedExports: Object.create(null), removedExports: Object.create(null) }; if (O(v.children).forEach(R => B(R, X, w, k)), k && u("templatemutation", X, _), w === "added" && !b(x, "oohtml").get("onLiveMode")) { b(x, "oohtml").set("onLiveMode", !0); let R = () => { if (!x.content.children.length) return b(x, "oohtml").delete("queryCallback"), c(x, _) }; x.getAttribute("src") && (x.getAttribute("loading") === "lazy" ? b(x, "oohtml").set("queryCallback", R) : f.push(R())), s.onAttrChange(x, j => { j[0].target.getAttribute(j[0].attributeName) !== j[0].oldValue && (x.getAttribute("loading") === "lazy" ? b(x, "oohtml").set("queryCallback", R) : j[0].attributeName === "loading" ? b(x, "oohtml").delete("queryCallback") : R()) }, ["src", "loading"]); var Je = new r.MutationObserver(j => { let xe = { addedTemplates: Object.create(null), removedTemplates: Object.create(null), addedExports: Object.create(null), removedExports: Object.create(null) }; j.forEach(Z => { Z.addedNodes.forEach(z => B(z, xe, "added", !0)), Z.removedNodes.forEach(z => B(z, xe, "removed", !0)) }), u("templatemutation", xe, _) }); Je.observe(v, { childList: !0 }) } }; if (n.get("api.templates") in i) throw new Error('document already has a "' + n.get("api.templates") + '" property!'); let f = []; if (Object.defineProperty(i, n.get("api.templates"), { get: function () { return m(b(i, "oohtml", "templates")) } }), n.get("api.templates") in o.prototype) throw new Error('The "HTMLTemplateElement" class already has a "' + n.get("api.templates") + '" property!'); if (Object.defineProperty(o.prototype, n.get("api.templates"), { get: function () { return b(this, "oohtml").has("queryCallback") && b(this, "oohtml").get("queryCallback")(), m(b(this, "oohtml", "templates")) } }), n.get("api.exports") in o.prototype) throw new Error('The "HTMLTemplateElement" class already has a "' + n.get("api.exports") + '" property!'); Object.defineProperty(o.prototype, n.get("api.exports"), { get: function () { return b(this, "oohtml").has("queryCallback") && b(this, "oohtml").get("queryCallback")(), m(b(this, "oohtml", "exports")) } }); let m = x => Object.defineProperties({}, Array.from(x.keys()).reduce((v, _) => (v[_] = { get: () => x.get(_) }, v), {})), p = x => { var v; return (v = x.match(/([^a-zA-Z0-9\_\-\@])/)) ? (console.error(`Invalid character "${v}" in the module name: ${x}.`), !1) : !0 }, g = x => { var v = i.createElement("template"); return mr([i], x, function (_, w) { var k = b(_, "oohtml", "templates"); return arguments.length === 1 ? k : w.startsWith(":") ? b(_, "oohtml", "exports").get(w.substr(1)) : k.get(w) }).forEach(_ => { b(_, "oohtml", "templates").forEach((w, k) => { b(v, "oohtml", "templates").set(k, w) }), b(_, "oohtml", "exports").forEach((w, k) => { b(v, "oohtml", "exports").has(k) || b(v, "oohtml", "exports").set(k, []), b(v, "oohtml", "exports").get(k).push(...w) }) }), v }; if (O(i.querySelectorAll(a)).forEach(async x => { var v = x.getAttribute(n.get("attr.moduleid")); !x.closest(n.get("element.import")) && p(v) && (b(i, "oohtml", "templates").set(v, x), h(x, x.content, v, "added", !1)) }), s.onPresenceChange(a, async (x, v) => { let _ = { addedTemplates: Object.create(null), removedTemplates: Object.create(null), addedExports: Object.create(null), removedExports: Object.create(null) }; x.forEach(w => { var k = w.getAttribute(n.get("attr.moduleid")); w.closest(n.get("element.import")) || !p(k) || (v ? (b(i, "oohtml", "templates").set(k, w), h(w, w.content, k, "added"), _.addedTemplates[k] = w) : (b(i, "oohtml", "templates").get(k) === w && b(i, "oohtml", "templates").delete(k), h(w, w.content, k, "removed"), _.removedTemplates[k] = w)) }), u("templatemutation", _, "") }), s.onPresent(n.get("element.import"), x => { h(x, x, "", "added", !1) }), n.get("api.moduleref") in r.Element.prototype) throw new Error('The "Element" class already has a "' + n.get("api.moduleref") + '" property!'); Object.defineProperty(r.Element.prototype, n.get("api.moduleref"), { get: function () { var x; if (!b(this, "oohtml").has("module") && (x = this.getAttribute(n.get("attr.moduleref")))) { var v = g(x); b(this, "oohtml").set("module", v) } return b(this, "oohtml").get("module") } }); var y = f.length ? "loading" : "indeterminate"; Object.defineProperty(i, "templatesReadyState", { get: () => y }), t.DOM.ready.call(t, () => (f.forEach(x => { x && x.catch(v => { console.warn(v) }) }), Promise.all(f).then(() => { y = "complete", i.dispatchEvent(new r.Event("templatesreadystatechange")) }))) } function xr(e = {}) { let t = ie.call(this); if (e.onDomReady) { t.DOM.ready(() => { xr.call(this, { ...e, onDomReady: !1 }) }); return } let r = t.window, i = t.window.document, s = t.DOM.mutations, n = [], a = Ee.call(this, { element: { import: "import" }, attr: { importid: "name", exportsearch: "exportsearch" } }, e.params); Wi.push(a.get("attr.importid"), a.get("attr.moduleref")); let o = "[" + r.CSS.escape(a.get("attr.moduleref")) + "]", u = "[" + r.CSS.escape(a.get("attr.exportgroup")) + "]", c, h = class { static create(p) { return b(this.el, "oohtml").get("instance") || new h(p) } constructor(p) { this.el = p, b(this.el, "oohtml").set("instance", this); let [g, y] = dr(p.getAttribute(a.get("attr.importid")) || "default"); b(this.el, "oohtml").set("importID", g), b(this.el, "oohtml").set("importModifiers", y) } hydrate(p, g, y) { b(this.el, "oohtml").set("anchorNode", p), b(this.el, "oohtml").set("slottedElements", g), b(this.el, "oohtml").set("compositionBlock", y), this._bindSlotted(g), this._connectToCompositionBlock() } connectedCallback() { b(this.el, "oohtml").has("anchorNode") || (b(this.el, "oohtml").set("anchorNode", a.get("isomorphic") ? i.createComment(this.el.outerHTML) : i.createTextNode("")), b(this.el, "oohtml").set("compositionBlock", this.el.hasAttribute(a.get("attr.moduleref")) ? this.el.getAttribute(a.get("attr.moduleref")).trim().startsWith("~") ? this.el.parentNode.closest(u) : null : this.el.parentNode.closest(o)), this._connectToCompositionBlock()), t.DOM.ready.call(t, () => { this.resolve("connected") }) } _connectToCompositionBlock() { this.compositionBlock && b(this.compositionBlock, "oohtml", "imports").set(this.importID, this.el) } _bindSlotted(p) { p.forEach(g => { g.importReference = this.el }), b(this.el, "oohtml").set("slottedObserver", s.onRemoved(p, (g, y, x, v, _) => { _ && _.size === p.length && b(this.el, "oohtml").get("slottedObserver").disconnect(), g.forEach(w => { w.parentNode || pt(this.slottedElements, w), w.importReference === this.el && delete w.importReference }), this.slottedElements.length || this.anchorNode.isConnected && this.anchorNode.replaceWith(this.el) }, { maintainCallState: !0, ignoreTransients: !0 })) } resolve(p = null) { if (!De(n, w => this.el.closest(w))) { var g = (w, k, B) => { var X = this.importID, Je = this.importModifiers, [R, j] = "search" in Je || B !== null ? ("search" in Je ? Je.search : B).split("-").filter(Z => Z).map(Z => parseInt(Z || 0)).concat([0, 1e3]) : [0, 0]; let xe = Z => Z.reduce((z, Me) => z.concat(b(Me, "oohtml", "exports").get(X) || []), []); return mr(w, k, function (Z, z) { var Me = b(Z, "oohtml", "templates"); return arguments.length === 1 ? Me : z.startsWith(":") ? b(Z, "oohtml", "exports").get(z.substr(1)) : Me.get(z) }, function (Z, z, Me) { var Ut = xe(Z); return !Ut.length && z > R && j ? (j--, -1) : Ut }) }, y, x; if (this.el.hasAttribute(a.get("attr.moduleref"))) this.compositionBlock && b(this.compositionBlock, "oohtml", "imports").get(this.importID) === this.el && b(this.compositionBlock, "oohtml", "imports").delete(this.importID), y = this.el; else { if (!this.compositionBlock) { console.warn("Scoped slots must be found within template contexts. [" + this.importID + "]", this.el); return } y = this.compositionBlock } var v = y.getAttribute(a.get("attr.moduleref")).trim(), _ = this.el.getAttribute(a.get("attr.exportsearch")); y && (x = g([v.startsWith("~") ? this.compositionBlock : i], v, _)).length ? ft(x, b(this.el, "oohtml").get("originalSlottedElements") || []).length && (b(this.el, "oohtml").set("originalSlottedElements", x), this.fill(x)) : (b(this.el, "oohtml").set("originalSlottedElements", null), this.empty()) } } fill(p) { p = O(p, !1).map(g => g.cloneNode(!0)), this.empty(!0), this.el.isConnected && this.el.replaceWith(this.anchorNode), p.forEach(g => { b(g, "oohtml", "templates").set("~", this.el), Xs(g, this.el), g.getAttribute(a.get("attr.exportgroup")) || g.setAttribute(a.get("attr.exportgroup"), this.importID), this.anchorNode.before(g) }), this._bindSlotted(p), this.slottedElements.push(...p) } empty(p = !1) { if (this.slottedElements) { var g = this.slottedElements; p && b(this.el, "oohtml").has("slottedObserver") && (b(this.el, "oohtml").get("slottedObserver").disconnect(), g = this.slottedElements.splice(0)), g.forEach(y => y.remove()) } } get importID() { return b(this.el, "oohtml").get("importID") } get importModifiers() { return b(this.el, "oohtml").get("importModifiers") } get anchorNode() { return b(this.el, "oohtml").get("anchorNode") } get compositionBlock() { return b(this.el, "oohtml").get("compositionBlock") } get slottedElements() { return b(this.el, "oohtml").has("slottedElements") || b(this.el, "oohtml").set("slottedElements", []), b(this.el, "oohtml").get("slottedElements") } get exports() { return b(this.el, "oohtml").get("exports") } static get observedAttributes() { return [a.get("attr.importid")] } }; s.onPresent(a.get("element.import"), p => { var g = h.create(p); g.connectedCallback() }); let f = (p, g, y = null) => { let x = (_, w) => !g || w === g || g === !0 && (_.importModifiers && "search" in _.importModifiers || _.el.getAttribute(a.get("attr.exportsearch"))); if (p.matches(a.get("element.import"))) { var v = h.create(p); x(v, v.importID) && v.resolve(y) } else b(p, "oohtml", "imports").forEach((_, w) => { var k = h.create(_); x(k, w) && k.resolve(`Resolution scope: ${y}`) }) }; s.onPresent(o, p => { De(n, g => p.closest(g)) || s.onAttrChange(p, g => { g[0].target.getAttribute(g[0].attributeName) !== g[0].oldValue && f(p, null, `Attr-Change: ${g[0].attributeName}`) }, [a.get("attr.moduleref"), a.get("attr.importid")]) }), i.addEventListener("templatemutation", p => { !p.detail.path || O(i.querySelectorAll("[" + r.CSS.escape(a.get("attr.moduleref")) + "]")).forEach(g => { $i(g.getAttribute(a.get("attr.moduleref")), p.detail.path) && (f(g, !0, `'templatemutation' event: ${p.detail.path}, search()`), p.detail.addedExports.concat(p.detail.removedExports).forEach(y => { f(g, y.name, `'templatemutation' event: ${p.detail.path}, ${y.name}`) })) }) }); let m = () => { O(i.querySelectorAll(u)).forEach(p => { if (!b(p.parentNode, "oohtml").get("importsCan") && !p.importReference) { var g = []; p.parentNode.childNodes.forEach(y => { var x; if (y.nodeType === 1 && y.matches(u)) g.push(y); else if (y.nodeType === 8 && (x = y.nodeValue.trim()) && x.startsWith("<" + a.get("element.import")) && x.endsWith("</" + a.get("element.import") + ">")) { var v, _ = i.createElement("div"); if (_.innerHTML = x, (v = _.firstChild).matches(a.get("element.import"))) { var w = v.hasAttribute(a.get("attr.moduleref")) ? v.getAttribute(a.get("attr.moduleref")).trim().startsWith("~") ? y.parentNode.closest(u) : null : y.parentNode.closest(o), k = h.create(v); k.hydrate(y, g, w), g = [] } } }), b(p.parentNode, "oohtml").set("importsCan", !0) } }) }; t.DOM.ready.call(t, () => { a.get("isomorphic") && m() }) } function Xs(e, t, r = [], i = !0) { r = r.concat(Wi), e.hasAttribute("noinherit") && (r = r.concat((e.getAttribute("noinherit") || "*").split(" ").map(o => o.trim()))); var s = en.concat(["role", "class"]); if (Xe(s).forEach(o => { var u, c; if (!r.includes(o) && !r.includes("*") && (u = t.getAttribute(o))) { if (c = e.getAttribute(o)) var h = i ? [c, u] : [u, c]; else var h = [u]; e.setAttribute(o, Xe(h.join(" ").split(" ").map(f => f.trim())).join(" ")), r.push(o) } }), Xe(Zs.concat("style")).forEach(o => { var u, c; if (!r.includes(o) && !r.includes("*") && (u = t.getAttribute(o))) { if (c = e.getAttribute(o)) { var h = i ? [c, u] : [u, c]; h[0].trim().endsWith(";") || (h[0] = h[0] + ";") } else var h = [u]; e.setAttribute(o, h.join(" ")), r.push(o) } }), !r.includes("*")) for (var n = 0; n < t.attributes.length; n++) { var a = t.attributes[n]; !r.includes(a.name) && (!e.hasAttribute(a.name) || i) && e.setAttribute(a.name, a.value) } return e } var Wi = ["nocompose"], Zs = [], en = []; function br(e = {}) { let t = ie.call(this); if (e.onDomReady) { t.DOM.ready(() => { br.call(this, { ...e, onDomReady: !1 }) }); return } let r = t.window, i = t.window.document, s = t.DOM.mutations, n = [], a = Ee.call(this, { attr: { namespace: "namespace", id: "id" }, api: { namespace: "namespace" }, eagermode: !0 }, e.params), o = function (c) { if (!b(c, "oohtml").has("namespace")) { let h = Object.create(null); b(c, "oohtml").set("namespace", h), U.link && U.link(c, a.get("api.namespace"), h) } return b(c, "oohtml").get("namespace") }, u = function (c) { if (!b(c, "oohtml").has("publicNamespace")) { let h = o(c); b(c, "oohtml").set("publicNamespace", a.get("eagermode") ? new Proxy(h, { get(f, m) { if (be(m) && !h[m]) { var p = O(c.querySelectorAll("[" + r.CSS.escape(a.get("attr.id")) + '="' + m + '"]')).filter(g => { var y = g.parentNode.closest("[" + r.CSS.escape(a.get("attr.namespace")) + "]"); return c === i ? !y : y === c })[0]; p && U.set(h, m, p) } return h[m] } }) : h) } return b(c, "oohtml").get("publicNamespace") }; if (a.get("api.namespace") in r.Element.prototype) throw new Error('The "Element" class already has a "' + a.get("api.namespace") + '" property!'); if (Object.defineProperty(r.Element.prototype, a.get("api.namespace"), { get: function () { return u(this) } }), a.get("api.namespace") in i) throw new Error('The "document" object already has a "' + a.get("api.namespace") + '" property!'); Object.defineProperty(i, a.get("api.namespace"), { get: function () { return u(i) } }), s.onPresent("[" + r.CSS.escape(a.get("attr.id")) + "]", c => { var h = b(c, "oohtml"); if (!(h.get("idAlreadyBeingWatched") || De(n, g => c.closest(g)))) { var f = c.getAttribute(a.get("attr.id")), m = c.parentNode.closest("[" + r.CSS.escape(a.get("attr.namespace")) + "]"); m || (m = i); var p = o(m); p[f] !== c && U.set(p, f, c), h.set("idAlreadyBeingWatched", !0), s.onPresenceChange(c, (g, y) => { y ? p[f] !== c && U.set(p, f, c) : p[f] === c && U.deleteProperty(p, f) }) } }) } function yr(e = {}) { let t = ie.call(this); if (e.onDomReady) { t.DOM.ready(() => { yr.call(this, { ...e, onDomReady: !1 }) }); return } let r = t.window, i = t.window.document, s = Ee.call(this, { api: { state: "state", setState: "setState", clearState: "clearState" } }, e.params), n = function (a, o = null) { if (!b(a, "oohtml").has("state") || o) { let u = o || Object.create(null), c = b(a, "oohtml").get("state"); if (b(a, "oohtml").set("state", u), c && U.unlink && U.unlink(a, s.get("api.state"), c), U.link) { let h = o ? { isUpdate: !!c, oldValue: c } : null; U.link(a, s.get("api.state"), u, h) } } return b(a, "oohtml").get("state") }; if (s.get("api.state") in r.Element.prototype) throw new Error('The "Element" class already has a "' + s.get("api.state") + '" property!'); if (Object.defineProperty(r.Element.prototype, s.get("api.state"), { get: function () { return U.proxy(n(this)) } }), s.get("api.setState") in r.Element.prototype) throw new Error('The "Element" class already has a "' + s.get("api.setState") + '" property!'); if (Object.defineProperty(r.Element.prototype, s.get("api.setState"), { value: function (a, o = {}) { if (!o.update) n(this, a); else { var u = n(this); if (o.update !== "merge") { var c = ft(Object.keys(u), Object.keys(a)); U.deleteProperty(u, c) } U.set(u, a) } } }), s.get("api.clearState") in r.Element.prototype) throw new Error('The "Element" class already has a "' + s.get("api.clearState") + '" property!'); if (Object.defineProperty(r.Element.prototype, s.get("api.clearState"), { value: function () { n(this, {}) } }), s.get("api.state") in i) throw new Error('The "document" object already has a "' + s.get("api.state") + '" property!'); if (Object.defineProperty(i, s.get("api.state"), { get: function () { return U.proxy(n(i)) } }), s.get("api.setState") in i) throw new Error('The "document" object already has a "' + s.get("api.setState") + '" property!'); if (Object.defineProperty(i, s.get("api.setState"), { value: function (a, o = {}) { if (!o.update) n(i, a); else { var u = n(i); if (o.update !== "merge") { var c = ft(Object.keys(u), Object.keys(a)); U.deleteProperty(u, c) } U.set(u, a) } } }), s.get("api.clearState") in i) throw new Error('The "document" object already has a "' + s.get("api.clearState") + '" property!'); Object.defineProperty(i, s.get("api.clearState"), { value: function () { n(i, {}) } }) } var { stringify: tn } = JSON; if (!String.prototype.repeat) throw new Error("String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation"); if (!String.prototype.endsWith) throw new Error("String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation"); var vr = { "||": 3, "&&": 4, "|": 5, "??": 5, "^": 6, "&": 7, "==": 8, "!=": 8, "===": 8, "!==": 8, "<": 9, ">": 9, "<=": 9, ">=": 9, in: 9, instanceof: 9, "<<": 10, ">>": 10, ">>>": 10, "+": 11, "-": 11, "*": 12, "%": 12, "/": 12, "**": 13 }, we = 17, rn = { ArrayExpression: 20, TaggedTemplateExpression: 20, ThisExpression: 20, Identifier: 20, PrivateIdentifier: 20, Literal: 18, TemplateLiteral: 20, Super: 20, SequenceExpression: 20, MemberExpression: 19, ChainExpression: 19, CallExpression: 19, NewExpression: 19, ArrowFunctionExpression: we, ClassExpression: we, FunctionExpression: we, ObjectExpression: we, UpdateExpression: 16, UnaryExpression: 15, AwaitExpression: 15, BinaryExpression: 14, LogicalExpression: 13, ConditionalExpression: 4, AssignmentExpression: 3, YieldExpression: 2, RestElement: 1 }; function yt(e, t) { let { generator: r } = e; if (e.write("("), t != null && t.length > 0) { r[t[0].type](t[0], e); let { length: i } = t; for (let s = 1; s < i; s++) { let n = t[s]; e.write(", "), r[n.type](n, e) } } e.write(")") } function Yi(e, t, r, i) { let s = e.expressionsPrecedence[t.type]; if (s === we) return !0; let n = e.expressionsPrecedence[r.type]; return s !== n ? !i && s === 15 && n === 14 && r.operator === "**" || s < n : s !== 13 && s !== 14 ? !1 : t.operator === "**" && r.operator === "**" ? !i : i ? vr[t.operator] <= vr[r.operator] : vr[t.operator] < vr[r.operator] } function wr(e, t, r, i) { let { generator: s } = e; Yi(e, t, r, i) ? (e.write("("), s[t.type](t, e), e.write(")")) : s[t.type](t, e) } function sn(e, t, r, i) {
        let s = t.split(`
`), n = s.length - 1; if (e.write(s[0].trim()), n > 0) { e.write(i); for (let a = 1; a < n; a++)e.write(r + s[a].trim() + i); e.write(r + s[n].trim()) }
    } function ee(e, t, r, i) {
        let { length: s } = t; for (let n = 0; n < s; n++) {
            let a = t[n]; e.write(r), a.type[0] === "L" ? e.write("// " + a.value.trim() + `
`, a) : (e.write("/*"), sn(e, a.value, r, i), e.write("*/" + i))
        }
    } function nn(e) { let t = e; for (; t != null;) { let { type: r } = t; if (r[0] === "C" && r[1] === "a") return !0; if (r[0] === "M" && r[1] === "e" && r[2] === "m") t = t.object; else return !1 } } function Yr(e, t) { let { generator: r } = e, { declarations: i } = t; e.write(t.kind + " "); let { length: s } = i; if (s > 0) { r.VariableDeclarator(i[0], e); for (let n = 1; n < s; n++)e.write(", "), r.VariableDeclarator(i[n], e) } } var zi, Qi, Hi, Gi, Ki, Ji, an = { Program(e, t) { let r = t.indent.repeat(t.indentLevel), { lineEnd: i, writeComments: s } = t; s && e.comments != null && ee(t, e.comments, r, i); let n = e.body, { length: a } = n; for (let o = 0; o < a; o++) { let u = n[o]; s && u.comments != null && ee(t, u.comments, r, i), t.write(r), this[u.type](u, t), t.write(i) } s && e.trailingComments != null && ee(t, e.trailingComments, r, i) }, BlockStatement: Ji = function (e, t) { let r = t.indent.repeat(t.indentLevel++), { lineEnd: i, writeComments: s } = t, n = r + t.indent; t.write("{"); let a = e.body; if (a != null && a.length > 0) { t.write(i), s && e.comments != null && ee(t, e.comments, n, i); let { length: o } = a; for (let u = 0; u < o; u++) { let c = a[u]; s && c.comments != null && ee(t, c.comments, n, i), t.write(n), this[c.type](c, t), t.write(i) } t.write(r) } else s && e.comments != null && (t.write(i), ee(t, e.comments, n, i), t.write(r)); s && e.trailingComments != null && ee(t, e.trailingComments, n, i), t.write("}"), t.indentLevel-- }, ClassBody: Ji, StaticBlock(e, t) { t.write("static "), this.BlockStatement(e, t) }, EmptyStatement(e, t) { t.write(";") }, ExpressionStatement(e, t) { let r = t.expressionsPrecedence[e.expression.type]; r === we || r === 3 && e.expression.left.type[0] === "O" ? (t.write("("), this[e.expression.type](e.expression, t), t.write(")")) : this[e.expression.type](e.expression, t), t.write(";") }, IfStatement(e, t) { t.write("if ("), this[e.test.type](e.test, t), t.write(") "), this[e.consequent.type](e.consequent, t), e.alternate != null && (t.write(" else "), this[e.alternate.type](e.alternate, t)) }, LabeledStatement(e, t) { this[e.label.type](e.label, t), t.write(": "), this[e.body.type](e.body, t) }, BreakStatement(e, t) { t.write("break"), e.label != null && (t.write(" "), this[e.label.type](e.label, t)), t.write(";") }, ContinueStatement(e, t) { t.write("continue"), e.label != null && (t.write(" "), this[e.label.type](e.label, t)), t.write(";") }, WithStatement(e, t) { t.write("with ("), this[e.object.type](e.object, t), t.write(") "), this[e.body.type](e.body, t) }, SwitchStatement(e, t) { let r = t.indent.repeat(t.indentLevel++), { lineEnd: i, writeComments: s } = t; t.indentLevel++; let n = r + t.indent, a = n + t.indent; t.write("switch ("), this[e.discriminant.type](e.discriminant, t), t.write(") {" + i); let { cases: o } = e, { length: u } = o; for (let c = 0; c < u; c++) { let h = o[c]; s && h.comments != null && ee(t, h.comments, n, i), h.test ? (t.write(n + "case "), this[h.test.type](h.test, t), t.write(":" + i)) : t.write(n + "default:" + i); let { consequent: f } = h, { length: m } = f; for (let p = 0; p < m; p++) { let g = f[p]; s && g.comments != null && ee(t, g.comments, a, i), t.write(a), this[g.type](g, t), t.write(i) } } t.indentLevel -= 2, t.write(r + "}") }, ReturnStatement(e, t) { t.write("return"), e.argument && (t.write(" "), this[e.argument.type](e.argument, t)), t.write(";") }, ThrowStatement(e, t) { t.write("throw "), this[e.argument.type](e.argument, t), t.write(";") }, TryStatement(e, t) { if (t.write("try "), this[e.block.type](e.block, t), e.handler) { let { handler: r } = e; r.param == null ? t.write(" catch ") : (t.write(" catch ("), this[r.param.type](r.param, t), t.write(") ")), this[r.body.type](r.body, t) } e.finalizer && (t.write(" finally "), this[e.finalizer.type](e.finalizer, t)) }, WhileStatement(e, t) { t.write("while ("), this[e.test.type](e.test, t), t.write(") "), this[e.body.type](e.body, t) }, DoWhileStatement(e, t) { t.write("do "), this[e.body.type](e.body, t), t.write(" while ("), this[e.test.type](e.test, t), t.write(");") }, ForStatement(e, t) { if (t.write("for ("), e.init != null) { let { init: r } = e; r.type[0] === "V" ? Yr(t, r) : this[r.type](r, t) } t.write("; "), e.test && this[e.test.type](e.test, t), t.write("; "), e.update && this[e.update.type](e.update, t), t.write(") "), this[e.body.type](e.body, t) }, ForInStatement: zi = function (e, t) { t.write(`for ${e.await ? "await " : ""}(`); let { left: r } = e; r.type[0] === "V" ? Yr(t, r) : this[r.type](r, t), t.write(e.type[3] === "I" ? " in " : " of "), this[e.right.type](e.right, t), t.write(") "), this[e.body.type](e.body, t) }, ForOfStatement: zi, DebuggerStatement(e, t) { t.write("debugger;", e) }, FunctionDeclaration: Qi = function (e, t) { t.write((e.async ? "async " : "") + (e.generator ? "function* " : "function ") + (e.id ? e.id.name : ""), e), yt(t, e.params), t.write(" "), this[e.body.type](e.body, t) }, FunctionExpression: Qi, VariableDeclaration(e, t) { Yr(t, e), t.write(";") }, VariableDeclarator(e, t) { this[e.id.type](e.id, t), e.init != null && (t.write(" = "), this[e.init.type](e.init, t)) }, ClassDeclaration(e, t) { if (t.write("class " + (e.id ? `${e.id.name} ` : ""), e), e.superClass) { t.write("extends "); let { superClass: r } = e, { type: i } = r, s = t.expressionsPrecedence[i]; (i[0] !== "C" || i[1] !== "l" || i[5] !== "E") && (s === we || s < t.expressionsPrecedence.ClassExpression) ? (t.write("("), this[e.superClass.type](r, t), t.write(")")) : this[r.type](r, t), t.write(" ") } this.ClassBody(e.body, t) }, ImportDeclaration(e, t) { t.write("import "); let { specifiers: r } = e, { length: i } = r, s = 0; if (i > 0) { for (; s < i;) { s > 0 && t.write(", "); let n = r[s], a = n.type[6]; if (a === "D") t.write(n.local.name, n), s++; else if (a === "N") t.write("* as " + n.local.name, n), s++; else break } if (s < i) { for (t.write("{"); ;) { let n = r[s], { name: a } = n.imported; if (t.write(a, n), a !== n.local.name && t.write(" as " + n.local.name), ++s < i) t.write(", "); else break } t.write("}") } t.write(" from ") } this.Literal(e.source, t), t.write(";") }, ImportExpression(e, t) { t.write("import("), this[e.source.type](e.source, t), t.write(")") }, ExportDefaultDeclaration(e, t) { t.write("export default "), this[e.declaration.type](e.declaration, t), t.expressionsPrecedence[e.declaration.type] != null && e.declaration.type[0] !== "F" && t.write(";") }, ExportNamedDeclaration(e, t) { if (t.write("export "), e.declaration) this[e.declaration.type](e.declaration, t); else { t.write("{"); let { specifiers: r } = e, { length: i } = r; if (i > 0) for (let s = 0; ;) { let n = r[s], { name: a } = n.local; if (t.write(a, n), a !== n.exported.name && t.write(" as " + n.exported.name), ++s < i) t.write(", "); else break } t.write("}"), e.source && (t.write(" from "), this.Literal(e.source, t)), t.write(";") } }, ExportAllDeclaration(e, t) { e.exported != null ? t.write("export * as " + e.exported.name + " from ") : t.write("export * from "), this.Literal(e.source, t), t.write(";") }, MethodDefinition(e, t) { e.static && t.write("static "); let r = e.kind[0]; (r === "g" || r === "s") && t.write(e.kind + " "), e.value.async && t.write("async "), e.value.generator && t.write("*"), e.computed ? (t.write("["), this[e.key.type](e.key, t), t.write("]")) : this[e.key.type](e.key, t), yt(t, e.value.params), t.write(" "), this[e.value.body.type](e.value.body, t) }, ClassExpression(e, t) { this.ClassDeclaration(e, t) }, ArrowFunctionExpression(e, t) { t.write(e.async ? "async " : "", e); let { params: r } = e; r != null && (r.length === 1 && r[0].type[0] === "I" ? t.write(r[0].name, r[0]) : yt(t, e.params)), t.write(" => "), e.body.type[0] === "O" ? (t.write("("), this.ObjectExpression(e.body, t), t.write(")")) : this[e.body.type](e.body, t) }, ThisExpression(e, t) { t.write("this", e) }, Super(e, t) { t.write("super", e) }, RestElement: Hi = function (e, t) { t.write("..."), this[e.argument.type](e.argument, t) }, SpreadElement: Hi, YieldExpression(e, t) { t.write(e.delegate ? "yield*" : "yield"), e.argument && (t.write(" "), this[e.argument.type](e.argument, t)) }, AwaitExpression(e, t) { t.write("await ", e), wr(t, e.argument, e) }, TemplateLiteral(e, t) { let { quasis: r, expressions: i } = e; t.write("`"); let { length: s } = i; for (let a = 0; a < s; a++) { let o = i[a], u = r[a]; t.write(u.value.raw, u), t.write("${"), this[o.type](o, t), t.write("}") } let n = r[r.length - 1]; t.write(n.value.raw, n), t.write("`") }, TemplateElement(e, t) { t.write(e.value.raw, e) }, TaggedTemplateExpression(e, t) { wr(t, e.tag, e), this[e.quasi.type](e.quasi, t) }, ArrayExpression: Ki = function (e, t) { if (t.write("["), e.elements.length > 0) { let { elements: r } = e, { length: i } = r; for (let s = 0; ;) { let n = r[s]; if (n != null && this[n.type](n, t), ++s < i) t.write(", "); else { n == null && t.write(", "); break } } } t.write("]") }, ArrayPattern: Ki, ObjectExpression(e, t) { let r = t.indent.repeat(t.indentLevel++), { lineEnd: i, writeComments: s } = t, n = r + t.indent; if (t.write("{"), e.properties.length > 0) { t.write(i), s && e.comments != null && ee(t, e.comments, n, i); let a = "," + i, { properties: o } = e, { length: u } = o; for (let c = 0; ;) { let h = o[c]; if (s && h.comments != null && ee(t, h.comments, n, i), t.write(n), this[h.type](h, t), ++c < u) t.write(a); else break } t.write(i), s && e.trailingComments != null && ee(t, e.trailingComments, n, i), t.write(r + "}") } else s ? e.comments != null ? (t.write(i), ee(t, e.comments, n, i), e.trailingComments != null && ee(t, e.trailingComments, n, i), t.write(r + "}")) : e.trailingComments != null ? (t.write(i), ee(t, e.trailingComments, n, i), t.write(r + "}")) : t.write("}") : t.write("}"); t.indentLevel-- }, Property(e, t) { e.method || e.kind[0] !== "i" ? this.MethodDefinition(e, t) : (e.shorthand || (e.computed ? (t.write("["), this[e.key.type](e.key, t), t.write("]")) : this[e.key.type](e.key, t), t.write(": ")), this[e.value.type](e.value, t)) }, PropertyDefinition(e, t) { e.static && t.write("static "), this[e.key.type](e.key, t), e.value != null && (t.write(" = "), this[e.value.type](e.value, t)) }, ObjectPattern(e, t) { if (t.write("{"), e.properties.length > 0) { let { properties: r } = e, { length: i } = r; for (let s = 0; this[r[s].type](r[s], t), ++s < i;)t.write(", ") } t.write("}") }, SequenceExpression(e, t) { yt(t, e.expressions) }, UnaryExpression(e, t) { if (e.prefix) { let { operator: r, argument: i, argument: { type: s } } = e; t.write(r); let n = Yi(t, i, e); !n && (r.length > 1 || s[0] === "U" && (s[1] === "n" || s[1] === "p") && i.prefix && i.operator[0] === r && (r === "+" || r === "-")) && t.write(" "), n ? (t.write(r.length > 1 ? " (" : "("), this[s](i, t), t.write(")")) : this[s](i, t) } else this[e.argument.type](e.argument, t), t.write(e.operator) }, UpdateExpression(e, t) { e.prefix ? (t.write(e.operator), this[e.argument.type](e.argument, t)) : (this[e.argument.type](e.argument, t), t.write(e.operator)) }, AssignmentExpression(e, t) { this[e.left.type](e.left, t), t.write(" " + e.operator + " "), this[e.right.type](e.right, t) }, AssignmentPattern(e, t) { this[e.left.type](e.left, t), t.write(" = "), this[e.right.type](e.right, t) }, BinaryExpression: Gi = function (e, t) { let r = e.operator === "in"; r && t.write("("), wr(t, e.left, e, !1), t.write(" " + e.operator + " "), wr(t, e.right, e, !0), r && t.write(")") }, LogicalExpression: Gi, ConditionalExpression(e, t) { let { test: r } = e, i = t.expressionsPrecedence[r.type]; i === we || i <= t.expressionsPrecedence.ConditionalExpression ? (t.write("("), this[r.type](r, t), t.write(")")) : this[r.type](r, t), t.write(" ? "), this[e.consequent.type](e.consequent, t), t.write(" : "), this[e.alternate.type](e.alternate, t) }, NewExpression(e, t) { t.write("new "); let r = t.expressionsPrecedence[e.callee.type]; r === we || r < t.expressionsPrecedence.CallExpression || nn(e.callee) ? (t.write("("), this[e.callee.type](e.callee, t), t.write(")")) : this[e.callee.type](e.callee, t), yt(t, e.arguments) }, CallExpression(e, t) { let r = t.expressionsPrecedence[e.callee.type]; r === we || r < t.expressionsPrecedence.CallExpression ? (t.write("("), this[e.callee.type](e.callee, t), t.write(")")) : this[e.callee.type](e.callee, t), e.optional && t.write("?."), yt(t, e.arguments) }, ChainExpression(e, t) { this[e.expression.type](e.expression, t) }, MemberExpression(e, t) { let r = t.expressionsPrecedence[e.object.type]; r === we || r < t.expressionsPrecedence.MemberExpression ? (t.write("("), this[e.object.type](e.object, t), t.write(")")) : this[e.object.type](e.object, t), e.computed ? (e.optional && t.write("?."), t.write("["), this[e.property.type](e.property, t), t.write("]")) : (e.optional ? t.write("?.") : t.write("."), this[e.property.type](e.property, t)) }, MetaProperty(e, t) { t.write(e.meta.name + "." + e.property.name, e) }, Identifier(e, t) { t.write(e.name, e) }, PrivateIdentifier(e, t) { t.write(`#${e.name}`, e) }, Literal(e, t) { e.raw != null ? t.write(e.raw, e) : e.regex != null ? this.RegExpLiteral(e, t) : e.bigint != null ? t.write(e.bigint + "n", e) : t.write(tn(e.value), e) }, RegExpLiteral(e, t) { let { regex: r } = e; t.write(`/${r.pattern}/${r.flags}`, e) } }, on = {}; var Xr = class {
        constructor(t) {
            let r = t ?? on; this.output = "", r.output != null ? (this.output = r.output, this.write = this.writeToStream) : this.output = "", this.generator = r.generator != null ? r.generator : an, this.expressionsPrecedence = r.expressionsPrecedence != null ? r.expressionsPrecedence : rn, this.indent = r.indent != null ? r.indent : "  ", this.lineEnd = r.lineEnd != null ? r.lineEnd : `
`, this.indentLevel = r.startingIndentLevel != null ? r.startingIndentLevel : 0, this.writeComments = r.comments ? r.comments : !1, r.sourceMap != null && (this.write = r.output == null ? this.writeAndMap : this.writeToStreamAndMap, this.sourceMap = r.sourceMap, this.line = 1, this.column = 0, this.lineEndSize = this.lineEnd.split(`
`).length - 1, this.mapping = { original: null, generated: this, name: void 0, source: r.sourceMap.file || r.sourceMap._file })
        } write(t) { this.output += t } writeToStream(t) { this.output.write(t) } writeAndMap(t, r) { this.output += t, this.map(t, r) } writeToStreamAndMap(t, r) { this.output.write(t), this.map(t, r) } map(t, r) {
            if (r != null) {
                let { type: n } = r; if (n[0] === "L" && n[2] === "n") { this.column = 0, this.line++; return } if (r.loc != null) { let { mapping: a } = this; a.original = r.loc.start, a.name = r.name, this.sourceMap.addMapping(a) } if (n[0] === "T" && n[8] === "E" || n[0] === "L" && n[1] === "i" && typeof r.value == "string") {
                    let { length: a } = t, { column: o, line: u } = this; for (let c = 0; c < a; c++)t[c] === `
`? (o = 0, u++) : o++; this.column = o, this.line = u; return
                }
            } let { length: i } = t, { lineEnd: s } = this; i > 0 && (this.lineEndSize > 0 && (s.length === 1 ? t[i - 1] === s : t.endsWith(s)) ? (this.line += this.lineEndSize, this.column = 0) : this.column += i)
        } toString() { return this.output }
    }; function Xi(e, t) { let r = new Xr(t); return r.generator[e.type](e, r), r.output } var te = class { constructor(t, r) { this.id = t, Object.assign(this, r), this.dependencies = 0 } with(t, r) { let i = {}; Object.keys(t).forEach(n => { i[n] = this[n], this[n] = t[n] }); let s = r(); return Object.keys(t).forEach(n => { this[n] = i[n] }), s } inUse(t) { return arguments.length ? (t ? this.dependencies++ : this.dependencies--, this) : this.dependencies > 0 } }; var nt = class extends te { constructor(t, r, i = {}) { super(r, i), this.ownerContract = t, this.refs = new Set, this.propertyStack = [], this.embeddingReference = null } withProperty(t, r) { this.propertyStack.unshift(t); let i = this.embeddingReference ? this.embeddingReference.withProperty(t, r) : r(); return this.propertyStack.shift(), i } get lineage() { return `${this.ownerContract.lineage}:${this.id}` } toJson(t = !1) { return { id: this.id, type: this.type, kind: this.kind, refs: Array.from(this.refs).map(r => r.toJson(t)), contractId: this.ownerContract.id } } }; var d = { tryStmt(e, t, r, i) { return { type: "TryStatement", block: e, handler: t, finalizer: r, guardedHandlers: i } }, catchClause(e, t) { return { type: "CatchClause", param: e, body: t } }, throwStmt(e) { return { type: "ThrowStatement", argument: e } }, returnStmt(e) { return { type: "ReturnStatement", argument: e } }, exprStmt(e) { return { type: "ExpressionStatement", expression: e } }, blockStmt(e) { return { type: "BlockStatement", body: e } }, labeledStmt(e, t) { return { type: "LabeledStatement", label: e, body: t } }, withStmt(e, t) { return { type: "WithStatement", object: e, body: t } }, ifStmt(e, t, r) { return this.condExpr(e, t, r, "IfStatement") }, switchStmt(e, t, r = !1) { return { type: "SwitchStatement", discriminant: e, cases: t } }, switchCase(e, t) { return { type: "SwitchCase", test: e, consequent: t } }, whileStmt(e, t) { return { type: "WhileStatement", test: e, body: t } }, doWhileStmt(e, t) { return { type: "DoWhileStatement", test: e, body: t } }, forStmt(e, t, r, i) { return { type: "ForStatement", init: e, test: t, update: r, body: i } }, forInStmt(e, t, r) { return { type: "ForInStatement", left: e, right: t, body: r } }, forOfStmt(e, t, r) { return { type: "ForOfStatement", left: e, right: t, body: r } }, breakStmt(e = null) { return { type: "BreakStatement", label: e } }, continueStmt(e = null) { return { type: "ContinueStatement", label: e } }, varDeclaration(e, t) { return { type: "VariableDeclaration", kind: e, declarations: t } }, varDeclarator(e, t = null) { return { type: "VariableDeclarator", id: e, init: t } }, funcDeclaration(e, t, r, i = !1, s = !1, n = !1) { return this.func("FunctionDeclaration", ...arguments) }, sequenceExpr(e) { return { type: "SequenceExpression", expressions: e } }, parensExpr(e) { return { type: "ParenthesizedExpression", expression: e } }, logicalExpr(e, t, r) { return { type: "LogicalExpression", operator: e, left: t, right: r } }, binaryExpr(e, t, r) { return { type: "BinaryExpression", operator: e, left: t, right: r } }, unaryExpr(e, t, r = !0) { return { type: "UnaryExpression", operator: e, argument: t, prefix: r } }, updateExpr(e, t, r = !1) { return { type: "UpdateExpression", operator: e, argument: t, prefix: r } }, assignmentExpr(e, t, r = "=") { return { type: "AssignmentExpression", operator: r, left: e, right: t } }, assignmentPattern(e, t) { return { type: "AssignmentPattern", left: e, right: t } }, thisExpr() { return { type: "ThisExpression" } }, condExpr(e, t, r, i = "ConditionalExpression") { return { type: i, test: e, consequent: t, alternate: r } }, arrayExpr(e) { return { type: "ArrayExpression", elements: e } }, arrayPattern(e) { return { type: "ArrayPattern", elements: e } }, objectExpr(e) { return { type: "ObjectExpression", properties: e } }, objectPattern(e) { return { type: "ObjectPattern", properties: e } }, chainExpr(e) { return { type: "ChainExpression", expression: e } }, callExpr(e, t, r = !1) { return { type: "CallExpression", callee: e, arguments: t, optional: r } }, newExpr(e, t) { return { type: "NewExpression", callee: e, arguments: t } }, awaitExpr(e) { return { type: "AwaitExpression", argument: e } }, taggedTemplateExpr(e, t) { return { type: "TaggedTemplateExpression", tag: e, quasi: t } }, memberExpr(e, t, r = !1, i = !1) { return { type: "MemberExpression", object: e, property: t, computed: r, optional: i } }, funcExpr(e, t, r, i = !1, s = !1, n = !1) { return this.func("FunctionExpression", ...arguments) }, arrowFuncExpr(e, t, r, i = !1, s = !1, n = !1) { return this.func("ArrowFunctionExpression", ...arguments) }, func(e, t, r, i, s = !1, n = !1, a = !1) { return { type: e, id: t, params: r, body: i, async: s, expression: n, generator: a } }, identifier(e) { return { type: "Identifier", name: e } }, property(e, t, r = "init", i = !1, s = !1, n = !1) { return { type: "Property", key: e, value: t, kind: r, shorthand: i, computed: s, method: n } }, methodDefinition(e, t, r = "method", i = !1, s = !1) { return { type: "MethodDefinition", key: e, value: t, kind: r, static: i, computed: s } }, spreadElement(e) { return { type: "SpreadElement", argument: e } }, literal(e) { return { type: "Literal", value: e } }, templateLiteral(e, t) { return { type: "TemplateLiteral", quasis: e, expressions: t } }, invert(e) { return this.unaryExpr("!", e) }, clone(e) { return e = { ...e }, delete e.start, delete e.end, e } }; var fe = class extends te { constructor(t, r, i) { super(r, i), this.ownerContext = t } generate() { if (!this.expr) return [this.expr, this]; let t = d.identifier(this.ownerContext.getSubscriptIdentifier("$contract", !0)), r = d.memberExpr(d.memberExpr(t, d.identifier("memo")), d.literal(this.id), !0); return this.composed = d.assignmentExpr(r, this.expr), [this.composed, this] } toJson(t = !1) { return { id: this.id } } }; var at = class extends te { constructor(t, r, i) { super(r, i), this.ownerReference = t, this.condition = this.ownerContract.currentCondition, this.path = [], this.isDotSafe = !0 } get ownerContract() { return this.ownerReference.ownerContract } push(...t) { return this.doIsDotSafe(t), this.path.push(...t), this } unshift(...t) { return this.doIsDotSafe(t), this.path.unshift(...t), this } doIsDotSafe(t) { t.some(r => r instanceof fe || (r.name + "").includes(".")) && (this.isDotSafe = !1) } match(t) { let r = (a, o) => !a || !o ? !1 : a instanceof fe && o instanceof fe ? a.id === o.id : a.name === o.name, i = this.path, s = Array.isArray(t) ? t : t.path, n = i.length - s.length; return n > 0 && ([i, s] = [s, i]), [i.reduce((a, o, u) => a && r(o, s[u]), !0), n] } toJson(t = !1) { return { id: this.id, path: this.path.map(r => r instanceof fe ? { memoId: r.id } : r), $path: this.isDotSafe ? this.path.map(r => r.name).join(".") : void 0, condition: (this.condition || {}).lineage, referenceId: this.ownerReference.id } } }; var Rt = class extends at { constructor(t, r, i) { super(t, r, i), this.subscriptions = new Map, this.$subscriptions = new Map, this.updates = new Map } subscribe(t, r, i = !1) { let s = i ? this.$subscriptions : this.subscriptions, n = s.get(t); n || (n = new Set, s.set(t, n)), n.add(r), this.updates.forEach(a => a.forEach(o => { o.subscribe(t, r, i) })) } update(t, r, i) { let s = this.updates.get(t); s || (s = new Set, this.updates.set(t, s)), s.add(r), i && this.subscriptions.forEach((n, a) => n.forEach(o => { r.subscribe(a, o, !0) })) } toJson(t = !1) { let { id: r, condition: i, referenceId: s, ...n } = super.toJson(t), a = {}, o = {}; return this.subscriptions.forEach((u, c) => { a[c.lineage] = Array.from(u).map(h => h.id) }), this.$subscriptions.forEach((u, c) => { o[c.lineage] = Array.from(u).map(h => h.id) }), { id: r, ...n, depth: this.depth.map(u => u instanceof fe ? { memoId: u.id } : u), subscriptions: a, $subscriptions: o, condition: i, referenceId: s } } }; var Ce = class extends nt { constructor(t, r, i) { super(t, r, i), this.destructuringStack = [] } withDestructure(t, r) { this.destructuringStack.push(t); let i = r(); return this.destructuringStack.pop(), i } addRef(t = {}) { let r = new Rt(this, this.refs.size, { ...t, condition: this.condition, depth: this.destructuringStack.slice(0) }); return r.push(...this.propertyStack), this.refs.add(r), r } doSubscribe(t, r) { let i = new Set(r); return this.refs.forEach((s, n) => { i.forEach(a => { let [o, u] = s.match(a); if (o && u <= 0) { if (this.kind === "const") return; s.subscribe(t, a), this.inUse(!0), s.condition && s.condition.inUse(!0), i.delete(a) } }) }), [...i] } doUpdate(t, r, i) { let s = new Set(r); return t === this ? [...s] : (this.refs.forEach((n, a) => { s.forEach(o => { let [u, c] = n.match(o); if (u && c >= 0) { if (this.kind === "const") throw new Error("Assignment to a constant declaration."); n.update(t, o, i), s.delete(o) } }) }), [...s]) } inUse(t) { let r = super.inUse(...arguments); return this.ownerContract.inUse(...arguments), r } }; var Mt = class extends at { }; var He = class extends nt { addRef(t) { let r = new Mt(this, this.refs.size, { ...t, condition: this.condition }); return r.push(...this.propertyStack), this.refs.add(r), r } setAssignee(t) { this.assignee = t } toJson(t = !1) { let r = super.toJson(t); return this.assignee && (r.assignee = this.assignee.id), r } }; var vt = class extends te { constructor(t, r, i = {}) { super(r, i), this.ownerContext = t, this.ownerScope = t && (t.currentScope || t.ownerScope), this.effectReferences = [] } pushEffectReference(t) { this.effectReferences.push(t) } doSubscribe(t, r = null) { if (r = this.effectReferences.reduce((i, s) => s.doSubscribe(t, i), r || [...t.refs]), !r.length) return !0; if (!this.ownerScope || ["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"].includes(this.type)) return r = this.ownerContext.references.reduce((i, s) => s instanceof Ce ? s.doSubscribe(t, i) : i, r), r.length ? this.ownerContext.effectReference({}, i => (r.forEach(s => { this.canObserveGlobal(s) && i.addRef().push(...s.path) }), t.inUse(!0), i.doSubscribe(t, r), !0), !1) : !0; if (this.ownerScope) return this.ownerScope.doSubscribe(t, r) } doUpdate(t, r = null) { if (r = this.effectReferences.reduce((i, s) => s.doUpdate(t, i), r || [...t.refs]), !this.ownerScope || ["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"].includes(this.type)) { if (t.type === "VariableDeclaration") return; t.ownerContract.$sideEffects = !0; let i = r.length && r || [...t.refs]; return this.ownerContext.sideEffects.push({ reference: t, remainderRefs: i }), !0 } if (!r.length) return !0; if (this.ownerScope) return this.ownerScope.doUpdate(t, r) } doSideEffectUpdates(t, r) { if (this.effectReferences.forEach(i => { let s = i.doUpdate(t, r, !0); i.type === "VariableDeclaration" && (r = s) }), !r.length) return !0; if (!this.ownerScope || ["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"].includes(this.type)) return this.ownerContext.sideEffects.push({ reference: t, remainderRefs: r, isSideEffects: !0 }), !0; if (this.ownerScope) return this.ownerScope.doSideEffectUpdates(t, r) } canObserveGlobal(t) { return (!this.ownerContext.$params.globalsOnlyPaths || t.path.length > 1) && !(this.ownerContext.$params.globalsNoObserve || []).includes(t.path[0].name) } }; var ot = class extends te { constructor(t, r, i) { super(r, i), this.ownerContext = t, this.ownerContract = t.currentContract || t, this.parent = t.currentCondition } inUse(t) { let r = super.inUse(...arguments), i = []; return this.switch ? i.push(this.switch, ...this.cases) : (this.when || this.whenNot) && i.push(this.when || this.whenNot), i.forEach(s => s.inUse(...arguments)), r } get lineage() { return `${this.ownerContract.lineage}:${this.id}` } toJson(t = !1) { let r = { id: this.id }; return this.switch ? (r.switch = this.switch.id, r.cases = this.cases.map(i => i.id)) : this.whenNot ? r.whenNot = this.whenNot.id : this.when && (r.when = this.when.id), this.parent && (this.parent.ownerContract.id === this.ownerContract.id ? r.parent = this.parent.id : r.parent = `${this.parent.ownerContract.lineage}:${this.parent.id}`), r } }; var ke = class extends te { constructor(t, r, i) { super(r, i), this.ownerContext = t, this.ownerContract = t && (t.currentContract || t), this.ownerScope = t && (t.currentScope || t.ownerScope), this.subscriptIdentifiers = {}, this.references = [], this.referenceStack = [], this.entries = [], this.entryStack = [], this.memos = [], this._hoistedAwaitKeyword = void 0, this._hoistedExitStatements = new Map, this._nextIds = {}, this.sideEffects = [], this.$sideEffects = !1 } get $params() { return this.params || this.ownerContract && this.ownerContract.$params } nextId(t) { return this.ownerContext ? this.ownerContext.nextId(t) : (t = "", typeof this._nextIds[t] > "u" && (this._nextIds[t] = 0), this._nextIds[t]++) } closest(t = null, r = !1, i = -1) { if (!arguments.length) return this.ownerContract; let s = i + 1; if (typeof t == "function" ? t(this, s) : [].concat(t).some(n => n === this.type)) return r ? { instance: this, level: s } : this; if (this.ownerContract) return this.ownerContract.closest(t, r, s) } closestContext(t = !1) { return this.closest(r => r instanceof Ae, t) } closestFunction(t = !1) { return this.closest(["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"], t) } defineSubscriptIdentifier(t, r, i = []) { this.subscriptIdentifiers[t] = { whitelist: r, blacklist: i, toString() { return this.whitelist[0] } } } getSubscriptIdentifier(t, r = !1) { return this.subscriptIdentifiers[t] || r && this.ownerContract && this.ownerContract.getSubscriptIdentifier(t, r) } subscriptIdentifiersNoConflict(t) { if (t.type !== "Identifier") throw new Error(`An implied Identifier is of type ${t.type}`); for (let r in this.subscriptIdentifiers) { let i = this.subscriptIdentifiers[r], s = i.whitelist.indexOf(t.name); s !== -1 && (i.blacklist.push(i.whitelist.splice(s, 1)), i.whitelist.length || (i.whitelist = i.blacklist.map(n => { let a; do { let o = String.fromCharCode(0 | Math.random() * 26 + 97); a = `${n}${o}` } while (i.blacklist.includes(a)); return a }))) } this.ownerContract && this.ownerContract.subscriptIdentifiersNoConflict(t) } get currentReference() { return this.referenceStack[0] } pushReference(t, r) { this.references.unshift(t); let i = this.currentReference; this.referenceStack.unshift(t); let s = r(t, i); if (this.referenceStack.shift() !== t) throw new Error("Reference stack corrupted."); return s } signalReference(t, r, i = !0) { let s = new He(this, this.nextId("causes"), t), n = this.pushReference(s, r), a = this.closestContext(), o = a.currentScope || a.ownerScope; return (!s.refs.size || i && !o.doSubscribe(s)) && (this.references = this.references.filter(u => u !== s)), n } effectReference(t, r, i = !0) { let s = new Ce(this, this.nextId("affecteds"), t), n = this.pushReference(s, r), a = this.closestContext(), o = a.currentScope || a.ownerScope; return o.pushEffectReference(s), s.refs.size ? (s.type !== "VariableDeclaration" || s.kind === "var") && i && o.doUpdate(s) : this.references = this.references.filter(u => u !== s), n } chainableReference(t, r) { return this.currentReference && this.currentReference.propertyStack.length ? r() : this.signalReference(t, r) } embeddableSignalReference(t, r) { return this.currentReference && this.signalReference(t, (i, s) => (i.embeddingReference = s, r(i, s))) } embeddableEffectReference(t, r) { return this.effectReference(t, (i, s) => (i.embeddingReference = s, r(i, s))) } get currentScope() { return this.entryStack.reduce((t, r) => t || r instanceof vt && r, null) } get currentCondition() { return this.entryStack.reduce((t, r) => t || r instanceof ot && r, null) || this.closestFunction() !== this && this.ownerContext && this.ownerContext.currentCondition } get currentContext() { return this.entryStack.reduce((t, r) => t || r instanceof Ae && r, null) } get currentContract() { return this.entryStack.reduce((t, r) => t || r instanceof ke && r, null) } get currentEntry() { return this.entryStack[0] } pushEntry(t, r) { this.entries.unshift(t), this.entryStack.unshift(t); let i = r(t); return this.entryStack.shift(), t instanceof ke && !t.generatable() && (this.entries = this.entries.filter(s => s !== t)), i } createScope(t, r) { let i = new vt(this, this.nextId("scope"), t); return this.pushEntry(i, r) } createCondition(t, r) { let i = new ot(this, this.nextId("condition"), t); return this.pushEntry(i, r) } defineContext(t, r) { let i = new Ae(this, this.nextId("context"), t); return this.pushEntry(i, r) } defineContract(t, r) { let i = new ke(this, this.nextId("contract"), t); return this.pushEntry(i, r) } defineMemo(t) { let r = new fe(this, this.nextId("memo"), t); return this.memos.unshift(r), r } getLabelInfo() { let t = this.type, r, i; return (this.ownerScope || {}).label ? { label: { name: r }, type: i } = this.ownerScope : t === "Iteration" && this.ownerContract.ownerScope.label && ({ label: { name: r }, type: i } = this.ownerContract.ownerScope), { type: t, label: r, target: i } } get hoistedAwaitKeyword() { return this._hoistedAwaitKeyword } get hoistedExitStatements() { return this._hoistedExitStatements } hoistAwaitKeyword() { ["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"].includes(this.type) || (this._hoistedAwaitKeyword = !0, this.ownerContract && this.ownerContract.hoistAwaitKeyword()) } hoistExitStatement(t, r) { if (["break", "continue"].includes(t.value)) { let i = this.getLabelInfo(); if (i.type === "Iteration" ? i.target !== "BlockStatement" && (r.value === i.label || !r.value) : r.value && r.value === i.label) return this._hoistedExitStatements.set(t, { ...i, arg: r }), i } if (this._hoistedExitStatements.set(t, r), this.ownerContract) return this.ownerContract.hoistExitStatement(t, r) } generatable() { return this.references.length || this instanceof Ae } generate(t, r = {}) { if (!t || !this.generatable()) return t; this.generated = !0; let i = d.identifier(this.ownerContract.getSubscriptIdentifier("$contract", !0)), s, n; r.isFunctionContract ? s = t : this.inSequence ? s = d.arrowFuncExpr(null, [i], t, this.hoistedAwaitKeyword, !0) : (n = Array.isArray(t) ? d.blockStmt(t) : d.blockStmt([t]), s = d.arrowFuncExpr(null, [i], n, this.hoistedAwaitKeyword)); let a = [d.literal(this.id), ...r.args || [], s], o = d.callExpr(i, a); if (this.hoistedAwaitKeyword && (o = d.awaitExpr(o)), this.inSequence || r.generateForArgument) return o; let u = this; o = d.exprStmt(o), o.comments = [{ type: "Line", value: { toString() { return u.lineage }, trim() { return this.toString() } } }]; let c = [o]; if (this.hookExpr = c, !(this.ownerScope || {}).singleStatementScope) { let h, f = [], m, p = (g, y) => { let x = d.ifStmt(g, y); m ? m.alternate = x : (m = x, c.push(x)) }; if (this.hoistedExitStatements.forEach((g, y) => { if (["break", "continue"].includes(y.value) && !f.includes(y.value) && g.arg) { let x = g.arg, v = d.callExpr(d.memberExpr(i, d.identifier("exiting")), [y, x]), _ = d.exprStmt(d.identifier(g.type === "Iteration" || !x.value ? y.value : y.value + " " + x.value)); p(v, _), f.push(y.value) } else h = !0 }), h) { let g = d.callExpr(d.memberExpr(i, d.identifier("exiting"))), y = d.exprStmt(d.identifier("return")); p(g, y) } } return c } get lineage() { let t = this.ownerContract && this.ownerContract.lineage; return this.ownerContract && !this.generated ? t : `${t ? t + "/" : ""}${this.id}` } toJson(t = !1) { let r = { id: this.id, lineage: this.lineage, type: this.type, signals: {}, effects: {}, sideEffects: this.sideEffects.length ? !0 : void 0, $sideEffects: this.$sideEffects === !0 ? !0 : void 0, subContracts: {}, conditions: {}, hoistedAwaitKeyword: this.hoistedAwaitKeyword, loc: this.loc }; this.references.forEach(n => { let a; n instanceof He ? a = r.signals : n instanceof Ce && (a = r.effects), a[n.id] = n.toJson(t) }); let i = this.lineage.split("/").length, s = n => n.reduce((a, o) => a.subContracts[o], r); return this.entries.slice(0).reverse().forEach(n => { if (n instanceof ke && n.generated) { let a = s(n.lineage.split("/").slice(i, -1)); a.subContracts[n.id] = n.toJson(t) } else if (n instanceof ot) { let a = s(n.ownerContract.lineage.split("/").slice(i)); a.conditions[n.id] = n.toJson(t) } }), r } }; var Ae = class extends ke { }; var ut = class { constructor(t = {}) { this.params = t, this.locations = [], this._locStart = this.params.locStart || 0, this.deferredTasks = [] } setLocation(t, r) { if (this.params.locations === !1 || !r) return; let i = [r.start + this._locStart, r.end + this._locStart]; this.params.locations === "detached" ? (this.locations.push(i), t.loc = this.locations.length - 1) : t.loc = i } serialize(t, r = {}) { return Xi(t, { comments: !0, ...r }) } generate(t) { let r = { type: "Global" }, i = new Ae(null, "#", { ...r, params: this.params }); i.defineSubscriptIdentifier("$contract", ["$x"]); let [s] = i.createScope(r, () => this.generateNodes(i, [t])); return this.deferredTasks.forEach(n => n()), { source: this.serialize(s), graph: i.toJson(!1), identifier: i.getSubscriptIdentifier("$contract"), locations: this.locations, ast: s } } generateNodes(t, r, i = !1) { let s = r.length; s > 1 && (r = r.reduce((a, o) => o.type === "FunctionDeclaration" ? [o].concat(a) : a.concat(o), [])); let n = a => { if (a === s) return []; let o = !1, u = () => (o = !0, n(a + 1)), c; if (r[a]) { let h = () => this.generateNode(t, r[a], i); this[`generate${r[a].type}`] && (!i || ["Identifier", "FunctionDeclaration", "FunctionExpression"].includes(r[a].type)) && (h = () => this[`generate${r[a].type}`].call(this, t, r[a], u)), c = h() } else c = [r[a]]; return o || (c = [].concat(c).concat(u(1))), c }; return n(0) } generateNode(t, r, i = !1) { return Object.keys(r).reduce((s, n) => { let a = r[n]; return Array.isArray(a) ? a = this.generateNodes(t, a, i) : typeof a == "object" && a && ([a] = this.generateNodes(t, [a], i)), { ...s, [n]: a } }, {}) } generateProgram(t, r) { let i = { type: r.type }, s = t.createScope(i, () => this.generateNodes(t, r.body)); return { ...r, body: s } } generateMethodDefinition(t, r) { let i = this.generateNode(t, r.value, !0); return d.methodDefinition(r.key, i, r.kind, r.static, r.computed) } generateFunctionDeclaration(t, r) { return this.generateFunction(d.funcDeclaration, ...arguments) } generateFunctionExpression(t, r) { return this.generateFunction(d.funcExpr, ...arguments) } generateArrowFunctionExpression(t, r) { return this.generateFunction(d.arrowFuncExpr, ...arguments) } generateFunction(t, r, i) { let s = (p, g) => p ? g.effectReference({ type: i.type }, () => this.generateNodes(g, [p]), !1) : [p], n = (p, g, y) => r.defineContext({ type: i.type, isSubscriptFunction: i.isSubscriptFunction }, x => x.createScope({ type: i.type }, () => (p = s(p, x)[0], g = g.map(v => { if (v.type === "AssignmentPattern") { let w = this.generateNode(x, v.right), k = { type: v.left.type }, [B] = x.effectReference(k, () => this.generateNodes(x, [v.left]), !1); return d.assignmentPattern(B, w) } let _ = { type: v.type }; return [v] = x.effectReference(_, () => this.generateNodes(x, [v]), !1), v }), i.type === "ArrowFunctionExpression" && i.expression ? y = this.generateNode(x, d.blockStmt([d.returnStmt(y)])) : y = this.generateNode(x, y), [x, p, g, y]))), a = d.identifier(r.getSubscriptIdentifier("$contract", !0)), o = (p, g, y, x, v) => g.generate(p.call(d, y, [a].concat(x), v, i.async, i.expression, i.generator), { args: [d.literal(i.type), d.identifier(i.isSubscriptFunction ? "true" : "false")], isFunctionContract: !0, generateForArgument: !0 }), u, c, h, f, m; if (i.type === "FunctionDeclaration") { [h] = s(i.id, r), [c, , f, m] = n(null, i.params, i.body), u = o(d.funcExpr, c, null, f, m); let p = d.memberExpr(a, d.identifier("functions")), g = (y, ...x) => d.callExpr(d.memberExpr(p, d.identifier(y)), [h, ...x]); u = [d.exprStmt(g("define", u)), t.call(d, h, f, d.blockStmt([d.returnStmt(d.callExpr(d.memberExpr(g("get"), d.identifier("call")), [d.thisExpr(), d.spreadElement(d.identifier("arguments"))]))]))] } else[c, h, f, m] = n(i.id, i.params, i.body), u = o(t, c, h, f, m); return this.deferredTasks.unshift(() => { c.sideEffects.forEach(p => { c.ownerScope.doSideEffectUpdates(p.reference, p.remainderRefs) }) }), u } generateVariableDeclaration(t, r) { let i = { type: r.type, kind: r.kind }, s = [], n = (u, c, h) => { let f, [m] = u.signalReference(i, _ => (f = _, this.generateNodes(t, [c.init]))), p, [g] = u.effectReference(i, _ => (p = _, this.generateNodes(t, [c.id]))); if (f.setAssignee(p), this.setLocation(u, c), h || r.kind === "const" || !c.init || !this.params.devMode && !u.references.filter(_ => _ instanceof He).length) return d.varDeclarator(g, m); let y = ["ObjectPattern", "ArrayPattern"].includes(c.id.type), x = Array.from(p.refs).map(_ => d.varDeclarator(d.identifier(_.path[0].name), null)), v = d.assignmentExpr(g, m); return s.length ? (s.push(d.varDeclaration(r.kind, x), ...u.generate(d.exprStmt(v))), []) : (s.push(...u.generate(d.exprStmt(v))), x) }, a = t.currentContract && ["ForStatement", "ForOfStatement", "ForInStatement"].includes(t.currentContract.type), o = r.declarations.reduce((u, c) => a ? u.concat(n(t.currentContract, c, !0)) : t.defineContract(i, h => u.concat(n(h, c))), []); return o.length ? [d.varDeclaration(r.kind, o), ...s] : s } generateIfStatement(t, r) { let i = { type: r.type }; return t.defineContract(i, s => { let { consequent: n, alternate: a } = r, [o] = s.signalReference(i, () => this.generateNodes(t, [r.test])), [u, c] = t.defineMemo({ expr: o }).generate(); return n = t.createCondition({ when: c }, () => this.generateNodes(t, [r.consequent])), n[0].type !== "BlockStatement" && n.length > 1 ? n = d.blockStmt(n) : n = n[0], r.alternate && (a = t.createCondition({ whenNot: c }, () => this.generateNodes(t, [r.alternate])), a[0] && a[0].type !== "BlockStatement" && a.length > 1 ? a = d.blockStmt(a) : a = a[0]), this.setLocation(s, r), this.setLocation(c, r.test), s.generate(d.ifStmt(u, n, a)) }) } generateSwitchStatement(t, r) { let i = { type: r.type }; return t.defineContract(i, s => { let [n] = s.signalReference(i, () => this.generateNodes(t, [r.discriminant])), [a, o] = t.defineMemo({ expr: n }).generate(), u = t.createScope(i, () => r.cases.reduce((c, h) => { let f = c.slice(-1)[0], m = h.consequent.some(v => v.type === "BreakStatement"), [p] = s.signalReference({ type: h.type }, () => this.generateNodes(t, [h.test])), [g, y] = t.defineMemo({ expr: p }).generate(), x = { switch: o, cases: [y] }; return f && !f.hasBreak && x.cases.push(...f.condition.cases), this.setLocation(y, h.test), c.concat({ caseNode: h, $test: g, condition: x, hasBreak: m }) }, []).map(({ caseNode: c, $test: h, condition: f }) => { let m = t.createCondition(f, () => this.generateNodes(t, c.consequent)); return d.switchCase(h, m) })); return this.setLocation(s, r), this.setLocation(o, r.discriminant), s.generate(d.switchStmt(a, u)) }) } generateWhileStatement(t, r) { return this.generateLoopStmtA(d.whileStmt, ...arguments) } generateDoWhileStatement(t, r) { return this.generateLoopStmtA(d.doWhileStmt, ...arguments) } generateForStatement(t, r) { return this.generateLoopStmtA(d.forStmt, ...arguments) } generateLoopStmtA(t, r, i) { let s = { type: i.type }; return r.defineContract({ type: i.type }, n => (this.setLocation(n, i), n.defineSubscriptIdentifier("$counter", ["$x_index"]), r.createScope({ type: "Iteration" }, () => { let a, o, u, c; return i.type === "ForStatement" ? ([o, u, c] = n.signalReference(s, () => this.generateNodes(r, [i.init, i.test, i.update])), a = h => t.call(d, o, u, c, h)) : ([u] = n.signalReference(s, () => this.generateNodes(r, [i.test])), a = h => t.call(d, u, h)), r.defineContext({ type: "Iteration", isIteration: !0 }, h => { this.setLocation(h, i.body); let f, [m] = this.generateNodes(h, [i.body]); m.body.length && ([f, m] = this.composeLoopStmt(h, m)); let p = [].concat(f || []).concat(a(d.blockStmt(m))); return n.generate(p) }) }))) } composeLoopStmt(t, r, i = {}) { let s = [i.disposeCallback], n = () => s.forEach(h => h && h()), a = [], o = [], u = [], c = r.body.slice(0); if (!i.iterationId) { i.iterationId = d.identifier(t.getSubscriptIdentifier("$counter", !0)); let h = d.varDeclarator(d.clone(i.iterationId), d.literal(-1)), f = d.updateExpr("++", d.clone(i.iterationId), !1); a.push(h), u.push(f), s.push(() => u.pop()) } return o.length && (u.push(d.varDeclaration("let", o)), s.push(() => u.splice(-1))), u.push(...t.generate(c, { args: [i.iterationId], disposeCallback: n })), a.length ? a = d.varDeclaration("let", a) : a = null, [a, u] } generateForOfStatement(t, r) { return this.generateLoopStmtB(d.forOfStmt, ...arguments) } generateForInStatement(t, r) { return this.generateLoopStmtB(d.forInStmt, ...arguments) } generateLoopStmtB(t, r, i) { let s = { type: i.type }; return r.defineContract({ type: i.type }, n => (this.setLocation(n, i), n.defineSubscriptIdentifier("$counter", [i.type === "ForInStatement" ? "$x_key" : "$x_index"]), r.createScope({ type: "Iteration" }, () => { let a, o; i.left.type === "VariableDeclaration" ? ([a] = this.generateNodes(r, [i.left]), o = a.declarations[0].id) : ([a] = n.affectedsReference(s, () => this.generateNodes(r, [i.left])), o = a); let [u] = n.signalReference(s, () => this.generateNodes(r, [i.right])); return r.defineContext({ type: "Iteration", isIteration: !0 }, c => { this.setLocation(c, i.body); let [h] = this.generateNodes(c, [i.body]), f = t.call(d, a, u, h), m = []; if (h.body.length) { let p = x => this.composeLoopStmt(c, h, { disposeCallback: () => { f.left = a }, ...x }), g = a, y = h; if (i.type === "ForOfStatement") [m, y] = p({}); else if (o.type === "Identifier") [m, y] = p({ iterationId: o }); else { let x = d.identifier(r.getSubscriptIdentifier("$counter"));[m, y] = p({ iterationId: x }), g = d.varDeclaration("let", [d.varDeclarator(d.clone(x), null)]); let v; i.left.type === "VariableDeclaration" ? v = d.varDeclaration(a.kind, [d.varDeclarator(o, d.clone(x))]) : v = d.exprStmt(d.sequenceExpr([d.assignmentExpr(o, d.clone(x), "=")])), y = [v].concat(y) } f = t.call(d, g, u, d.blockStmt(y)) } return n.generate([].concat(m || []).concat(f)) }) }))) } generateLabeledStatement(t, r) { t.subscriptIdentifiersNoConflict(r.label); let i = { type: r.type, label: r.label }; return r.body.type.endsWith("Statement") ? t.createScope({ type: r.body.type, label: r.label }, s => { if (r.body.type === "BlockStatement") { let a = this.generateNodes(t, r.body.body); return d.labeledStmt(r.label, d.blockStmt(a)) } s.singleStatementScope = !0; let [n] = this.generateNodes(t, [r.body]); return d.labeledStmt(r.label, n) }) : t.defineContract(i, s => { this.setLocation(s, r.body); let [n] = this.generateNodes(t, [r.body]); return d.labeledStmt(r.label, s.generate(n)) }) } generateBreakStatement(t, r) { return this.generateExitStmt(d.breakStmt, ...arguments) } generateContinueStatement(t, r) { return this.generateExitStmt(d.continueStmt, ...arguments) } generateExitStmt(t, r, i) { let s = r.currentContract.closest(["Iteration", "SwitchStatement", "LabeledStatement"]); if (s && s.type === "SwitchStatement" && i.type === "BreakStatement" && !i.label) return t.call(d, null); let n = d.identifier(r.getSubscriptIdentifier("$contract", !0)), a = d.literal(i.type === "BreakStatement" ? "break" : "continue"), o = i.label ? d.literal(i.label.name) : d.identifier("null"), u = d.exprStmt(d.callExpr(d.memberExpr(n, d.identifier("exit")), [a, o])); return r.currentContract.hoistExitStatement(a, o), [u, d.returnStmt()] } generateReturnStatement(t, r) { let i = { type: r.type }; return t.defineContract(i, s => { let [n] = s.signalReference(i, () => this.generateNodes(t, [r.argument])), a = d.identifier(t.getSubscriptIdentifier("$contract", !0)), o = d.literal("return"), u = n || d.identifier("undefined"), c = d.exprStmt(d.callExpr(d.memberExpr(a, d.identifier("exit")), [o, u])); return s.hoistExitStatement(o, d.identifier("true")), s.generate([c, d.returnStmt()]) }) } generateBlockStatement(t, r) { return t.createScope({ type: r.type }, () => { let i = this.generateNodes(t, r.body); return d.blockStmt(i) }) } generateExpressionStatement(t, r) { let i = { type: r.type }; return t.defineContract(i, s => { this.setLocation(s, r.expression); let [n] = s.signalReference(i, () => this.generateNodes(t, [r.expression])); return s.generate(d.exprStmt(n)) }) } generateSequenceExpression(t, r) { let i = r.expressions.map((s, n) => { let a = { type: s.type, inSequence: !0 }; return n === r.expressions.length - 1 ? ([s] = t.currentContract.chainableReference(a, () => this.generateNodes(t, [s])), s) : t.defineContract(a, o => (this.setLocation(o, s), [s] = o.signalReference(a, () => this.generateNodes(t, [s])), s.type === "Identifier" ? s : o.generate(s))) }); return d.sequenceExpr(i) } generateAssignmentExpression(t, r) { let i = { type: r.type, kind: r.operator }, s, [n] = t.currentContract.signalReference(i, u => (s = u, this.generateNodes(t, [r.right]))), a, [o] = t.currentContract.embeddableEffectReference(i, u => (a = u, this.generateNodes(t, [r.left]))); return s.setAssignee(a), d.assignmentExpr(o, n, r.operator) } generateUpdateExpression(t, r) { return this.generateMutationExpr(d.updateExpr, ...arguments) } generateUnaryExpression(t, r) { if (r.operator === "delete") return this.generateMutationExpr(d.unaryExpr, ...arguments); let i = { type: r.type, kind: r.operator }, [s] = t.currentContract.signalReference(i, () => this.generateNodes(t, [r.argument])); return d.unaryExpr(r.operator, s, r.prefix) } generateMutationExpr(t, r, i) { let s = { type: i.type, kind: i.operator }, [n] = r.currentContract.effectReference(s, () => this.generateNodes(r, [i.argument])); return t.call(d, i.operator, n, i.prefix) } generateBinaryExpression(t, r) { let [i] = t.currentContract.signalReference({ type: r.type }, () => this.generateNodes(t, [r.left])), [s] = t.currentContract.signalReference({ type: r.type }, () => this.generateNodes(t, [r.right])); return d.binaryExpr(r.operator, i, s) } generateLogicalExpression(t, r) { let i = { type: r.type, kind: r.operator }, [s] = t.currentContract.chainableReference(i, () => this.generateNodes(t, [r.left])), [n, a] = t.defineMemo({ expr: s }).generate(), o = r.operator === "||" ? { whenNot: a } : { when: a }, [u] = t.createCondition(o, () => t.currentContract.chainableReference(i, () => this.generateNodes(t, [r.right]))); return this.setLocation(a, r.left), d.logicalExpr(r.operator, n, u) } generateConditionalExpression(t, r) { let i = { type: r.type }, [s] = t.currentContract.signalReference(i, () => this.generateNodes(t, [r.test])), [n, a] = t.defineMemo({ expr: s }).generate(), [o] = t.createCondition({ when: a }, () => t.currentContract.chainableReference(i, () => this.generateNodes(t, [r.consequent]))), [u] = t.createCondition({ whenNot: a }, () => t.currentContract.chainableReference(i, () => this.generateNodes(t, [r.alternate]))); return this.setLocation(a, r.test), d.condExpr(n, o, u) } generateArrayPattern(t, r) { let i = r.elements.map((s, n) => ([s] = t.currentContract.currentReference.withDestructure({ name: n }, () => this.generateNodes(t, [s])), s)); return d.arrayPattern(i) } generateObjectPattern(t, r) { let i = r.properties.map(s => { let { key: n, value: a } = s; s.computed && ([n] = t.currentContract.signalReference({ type: n.type }, () => this.generateNodes(t, [n]))); let o = { name: s.key.name }; return s.computed && (s.key.type === "Literal" ? o = { name: s.key.value } : [n, o] = t.defineMemo({ expr: n }).generate()), [a] = t.currentContract.currentReference.withDestructure(o, () => this.generateNodes(t, [a])), this.setLocation(o, s.key), d.property(n, a, s.kind, s.shorthand, s.computed, s.method) }); return d.objectPattern(i) } generateMemberExpression(t, r) { let { property: i } = r; r.computed && ([i] = t.currentContract.signalReference({ type: i.type }, () => this.generateNodes(t, [i]))); let s = { name: r.property.name }; r.computed && (r.property.type === "Literal" ? s = { name: r.property.value } : [i, s] = t.defineMemo({ expr: i }).generate()); let [n] = t.currentContract.currentReference.withProperty(s, () => this.generateNodes(t, [r.object])); return this.setLocation(s, r.property), d.memberExpr(n, i, r.computed, r.optional) } generateThisExpression(t, r) { return this.generateIdentifier(...arguments) } generateIdentifier(t, r) { let i = () => r.type === "Identifier" ? d.identifier(r.name) : d.thisExpr(); r.type === "Identifier" && t.subscriptIdentifiersNoConflict(r); let s = { name: r.type === "Identifier" ? r.name : "this" }; this.setLocation(s, r); let n = t.closestFunction(), a = (t.currentContract || t).currentReference; if (a) do (!n || n.isSubscriptFunction || a instanceof Ce) && a.addRef().unshift(s); while (a = a.contextReference); return i() } generateSpreadElement(t, r) { return this.generateArgumentExpr(d.spreadElement, ...arguments) } generateAwaitExpression(t, r) { return t.currentContract.hoistAwaitKeyword(), this.generateArgumentExpr(d.awaitExpr, ...arguments) } generateArgumentExpr(t, r, i) { let [s] = r.currentContract.signalReference({ type: i.type }, () => this.generateNodes(r, [i.argument])); return t.call(d, s) } generateCallExpression(t, r) { return this.generateCallExpr(d.callExpr, ...arguments) } generateNewExpression(t, r) { return this.generateCallExpr(d.newExpr, ...arguments) } generateCallExpr(t, r, i) { let [s] = r.currentContract.signalReference({ type: i.callee.type }, () => this.generateNodes(r, [i.callee])), n = i.arguments.map(a => r.currentContract.signalReference({ type: a.type }, () => this.generateNodes(r, [a])[0])); return t.call(d, s, n, i.optional) } generateParenthesizedExpression(t, r) { return this.generateExprExpr(d.parensExpr, ...arguments) } generateChainExpression(t, r) { return this.generateExprExpr(d.chainExpr, ...arguments) } generateExprExpr(t, r, i) { let [s] = this.generateNodes(r, [i.expression]); return t.call(d, s) } generateArrayExpression(t, r) { let i = r.elements.map(s => t.currentContract.signalReference({ type: s.type }, () => this.generateNodes(t, [s])[0])); return d.arrayExpr(i) } generateObjectExpression(t, r) { let i = this.generateNodes(t, r.properties); return d.objectExpr(i) } generateProperty(t, r) { let { key: i, value: s } = r; return r.computed && ([i] = t.currentContract.signalReference({ type: i.type }, () => this.generateNodes(t, [i]))), [s] = t.currentContract.signalReference({ type: s.type }, () => this.generateNodes(t, [s])), d.property(i, s, r.kind, r.shorthand, r.computed, !1) } generateTaggedTemplateExpression(t, r) { let [i, s] = t.currentContract.signalReference({ type: r.type }, () => this.generateNodes(t, [r.tag, r.quasi])); return d.taggedTemplateExpr(i, s) } generateTemplateLiteral(t, r) { let i = r.expressions.map(s => t.currentContract.signalReference({ type: r.type }, () => this.generateNodes(t, [s])[0])); return d.templateLiteral(r.quasis, i) } generateTryStatement(t, r) { let [i, s, n] = this.generateNodes(t, [r.block, r.handler, r.finalizer]); return d.tryStmt(i, s, n) } generateCatchClause(t, r) { let [i] = this.generateNodes(t, [r.body]); return d.catchClause(r.param, i) } generateThrowStatement(t, r) { return this.generateArgumentExpr(d.throwStmt, ...arguments) } }; var Te = class { constructor(t, r, i, s = {}, n = null, a = null) { this.ownerContract = t, this.graph = r, this.callee = i, this.params = s, this.exits = a || new Map, this.$thread = n || { entries: new Map, sequence: [], ownerContract: this }, this.subContracts = new Map, this.contract = function (u, c, h = null, f = null) { if (!this.graph.subContracts[u]) throw new Error(`[${this.graph.type}:${this.graph.lineage}]: Graph not found for child contract ${u}.`); let m = this.graph.subContracts[u], p = { ...this.params, isIterationContract: arguments.length === 3, iterationId: arguments.length === 3 && c, isFunctionContract: arguments.length === 4, functionType: arguments.length === 4 && c, isSubscriptFunction: arguments.length === 4 && h, functionScope: this.params.isFunctionContract && this.graph.lineage || this.params.functionScope }; if (p.isIterationContract) { let v = h, _ = new Te(this, m, v, p, this.$thread, this.exits), w = this.subContracts.get(u); return w || (w = new Map, this.subContracts.set(u, w)), w.has(p.iterationId) && w.get(p.iterationId).dispose(), w.set(p.iterationId, _), _.call() } let g, y, x; return this.subContracts.has(u) && this.subContracts.get(u).dispose(), p.isFunctionContract ? (g = f, x = y = new Te(this, m, g, p), p.functionType !== "FunctionDeclaration" && (x = g instanceof (async () => { }).constructor ? async function () { return y.call(this, ...arguments) } : function () { return y.call(this, ...arguments) }, o(x, y))) : (g = c, y = new Te(this, m, g, p, this.$thread, this.exits), x = y.call()), this.subContracts.set(u, y), x }.bind(this), this.contract.memo = Object.create(null), this.contract.exiting = function (u, c) { if (!arguments.length) return this.exits.size; let h = this.exits.get(u) === c; return h && this.exits.clear(), h }.bind(this), this.contract.exit = function (u, c) { this.exits.set(u, c) }.bind(this), this.contract.functions = new Map, this.contract.functions.define = (u, c) => { this.contract.functions.set(u, c), o(u, c, !0) }; let o = (u, c, h = !1) => { h || (Object.defineProperty(u, "length", { configurable: !0, value: c.callee.length - 1 }), Object.defineProperty(u, "name", { configurable: !0, value: c.callee.name })), c.params.isSubscriptFunction && (u.thread = c.thread.bind(c), u.dispose = c.dispose.bind(c), Object.defineProperty(u, "runtime", { value: c }), Object.defineProperty(u, "sideEffects", { configurable: !0, value: c.graph.sideEffects || "" }), Object.defineProperty(u, "subscriptSource", { configurable: !0, value: c.graph.subscriptSource || "" }), Object.defineProperty(u, "originalSource", { configurable: !0, value: c.graph.originalSource || "" })) } } fire(t, r, i) { if (!!this.ownerContract) return this.ownerContract.fire(t, r, i) } call(t, ...r) { if (this.disposed) throw new Error(`[${this.graph.type}:${this.graph.lineage}]: Instance not runable after having been disposed.`); let i = this.callee.call(t, this.contract, ...r); if (this.graph.$sideEffects) for (let s in this.graph.effects) for (let n of this.graph.effects[s].refs) this.buildThread([], n, [], 0, !0); if (!this.ownerContract || this.params.isFunctionContract) { let s = this.exits.get("return"); this.exits.clear(), s !== void 0 && (i = i instanceof Promise ? i.then(() => s) : s) } return i } iterate(t = []) { if (this.disposed) return !1; if (!["ForOfStatement", "ForInStatement"].includes(this.graph.type) || this.subContracts.size !== 1) throw new Error(`Contract ${this.graph.lineage} is not an iterator.`); let [[, r]] = this.subContracts, i, s = (n, a) => n instanceof Promise ? n.then(a) : a(); if (!t.length || t.includes("length") && this.graph.type === "ForOfStatement") for (let [, n] of r) i = s(i, () => n.call()); else for (let n of t) { let a = r.get(n) || r.get(parseInt(n)); !a || (i = s(i, () => a.call())) } return i } thread(...t) { if (this.disposed) return !1; this.$thread.active = !0; for (let r in this.graph.effects) for (let i of this.graph.effects[r].refs) for (let s of t) { let [n, a, o] = this.matchRefs(s, i); !n || this.buildThread(s, i, o, a) } return this.runThread() } runThread() { let t = (a, o) => { if (["ForOfStatement", "ForInStatement"].includes(a.graph.type) && o.every(u => u.executionPlan.isIterationContractTarget)) { let u = o.map(c => c.executionPlan.iterationTarget); return this.fire(a.graph.lineage, "iterating", o), a.iterate(u) } return this.fire(a.graph.lineage, "executing", o), a.call() }, r, i, s, n = (a, o) => a instanceof Promise ? a.then(o) : o(); for (; (i = this.$thread.sequence.shift()) && (s = [...this.$thread.entries.get(i)]) && this.$thread.entries.delete(i);)r = n(r, () => { if (i.disposed || !i.filterRefs(s).length) return; this.$thread.current = i; let a = t(i, s); return n(a, () => { for (let o of s) [].concat(o.executionPlan.assigneeRef || o.executionPlan.assigneeRefs || []).forEach(u => { i.buildThread([], u, [], 0) }) }), a }); return n(r, () => { let a = this.exits.get("return"); return this.exits.clear(), this.$thread.current = null, this.$thread.active = !1, a }) } buildThread(t, r, i, s = 0, n = !1) { let a = s > 0; if (this.ownerContract) { if (!this.compute(i) || r.condition !== void 0 && !this.assert(r.condition)) return } else a || (a = i.length || r.condition !== void 0); let o = n ? r.$subscriptions : r.subscriptions; Object.keys(o).forEach(u => { let [c, h] = u.split(":"), f = p => { !p || p.selectRefs(h, o[u], a ? t : null) }, m = this.locate(c); Array.isArray(m) ? m.forEach(f) : f(m) }) } selectRefs(t, r, i = null) { let s = this.$thread, n = this.graph.signals[t], a = (u, c) => u.graph.lineage.localeCompare(c.graph.lineage, void 0, { numeric: !0 }), o = (u, c = [], h = {}) => { if (!s.active || s.current && a(this, s.current) < 0) return; let f = s.entries.get(this); if (f || (f = new Set, s.entries.set(this, f), s.sequence.push(this), s.sequence.sort(a)), f.add({ ...u, computes: c, executionPlan: h }), !h.assigneeRef && ["VariableDeclaration", "AssignmentExpression"].includes(this.graph.type)) { h.assigneeRefs = []; for (let m in this.graph.effects) h.assigneeRefs.push(...this.graph.effects[m].refs) } }; for (let u of r) { let c = n.refs[u]; if (!i) { o(c); continue } let [h, f, m] = this.matchRefs(i, c); if (!h) continue; if (f <= 0) { o(c, m); continue } let p = i.slice(-f), g = "assignee" in n ? this.graph.effects[n.assignee] : null; if (g) { g.refs.forEach(y => { if (y.depth.length) { let [x, v, _] = this.matchRefs(p, y.depth), w = m.concat(_); if (x && v > 0) { let k = y.path.concat(p.slice(-v)); this.buildThread(k, y, w, v) } else x && o(c, w, { assigneeRef: y }) } else { let x = y.path.concat(p); this.buildThread(x, y, m, f) } }); continue } if (f === 1 && this.graph.type === "ForOfStatement") { o(c, m, { isIterationContractTarget: !0, iterationTarget: p[0] }); continue } if (f === 1 && this.graph.type === "ForInStatement") { o(c, m, { isIterationContractTarget: !0, iterationTarget: p[0] }); continue } } } filterRefs(t) { return t.filter(r => { if (!!this.compute(r.computes) && !(r.condition !== void 0 && !this.assert(r.condition))) return !0 }) } matchRefs(t, r) { let i, s, n, a; Array.isArray(t) ? (i = t, s = t.dotSafe ? t.join(".") : void 0) : (i = t.path, s = t.$path), Array.isArray(r) ? (n = r, a = r.dotSafe ? r.join(".") : void 0) : (n = r.path, a = r.$path); let o = i.length - n.length; if (o > 0 && ([i, n, s, a] = [n, i, a, s]), s && a) return [`${a}.`.startsWith(`${s}.`), o, []]; let u = [], c = f => typeof f == "object" ? f.name : f, h = (f, m) => { if (!f || !m) return !1; let p = typeof f == "object" && "memoId" in f, g = typeof m == "object" && "memoId" in m; return p || g ? (u.push(y => (p ? y[f.memoId] : c(f)) === (g ? y[m.memoId] : c(m))), !0) : c(f) === c(m) }; return [i.reduce((f, m, p) => f && h(m, n[p]), !0), o, u] } locate(t) { let r = this.graph.lineage + "/", i = t + "/"; if (i === r) return this; if (i.startsWith(r)) { let s = t.slice(r.length).split("/"), n = this.subContracts.get(parseInt(s.shift())); if (s.length) { if (n instanceof Map) return Array.from(n).reduce((a, [o, u]) => a.concat(u.locate(t)), []); if (n) return n.locate(t) } return n } if (this.ownerContract) return this.ownerContract.locate(t) } compute(t) { return !t.some(r => r(this.contract.memo) === !1) } assert(t) { if (typeof t == "string" && t.includes(":")) { let [s, n] = t.split(":"); return this.locate(s).assert(n) } let r = this.graph.conditions[t], i = this.contract.memo; return typeof r.parent < "u" && !this.assert(r.parent) ? !1 : typeof r.switch < "u" ? r.cases.some(s => i[s] === i[r.switch]) : typeof r.whenNot < "u" ? !i[r.whenNot] : typeof r.when < "u" ? i[r.when] : !0 } dispose() { this.params.isFunctionContract || (this.subContracts.forEach((t, r) => { t instanceof Map ? (t.forEach(i => i.dispose()), t.clear()) : t.dispose() }), this.subContracts.clear(), delete this.ownerContract, delete this.callee, delete this.params, delete this.contract.memo, this.disposed = !0) } }; var wt = class extends Te { static create(t, r = [], i = {}) { let s = t.graph.hoistedAwaitKeyword ? Object.getPrototypeOf(async function () { }).constructor : Function, n = i.compileFunction ? i.compileFunction(t.source, [t.identifier + ""].concat(r)) : new s(t.identifier + "", ...r, t.source); return new this(null, t.graph, n, i) } constructor(t, r, i, s = {}, n = null) { super(t, r, i, s = {}, n), this.observers = [] } observe(t, r) { this.params.devMode, this.observers.push({ contractUrl: t, callback: r }) } fire(t, r, i) { (this.observers || []).forEach(s => { s.contractUrl === t && s.callback(r, i) }) } }; function Zr(e, t = !1) {
        let r = e.split(/\n/g); if (r.length > 1) {
            for (; !r[0].trim().length;)r.shift(); let i = r[t ? 1 : 0].split(/[^\s]/)[0].length; if (i) return r.map((s, n) => { let a = s.substring(0, i); return a.trim().length ? a.trim() === "}" && n === r.length - 1 ? "}" : s : s.substring(i) }).join(`
`)
        } return e
    } function V(...e) { let t = typeof e[e.length - 1] == "object" ? e.pop() : {}; t.compilerParams = { ...V.compilerParams, ...t.compilerParams || {} }, t.runtimeParams = { ...V.runtimeParams, ...t.runtimeParams || {} }; let r = Zr(e.pop() || ""), i, s = e; if (V.cache[r] && !t.compilerParams.devMode && ti(s, V.cache[r][1]) && ri(t.compilerParams, V.cache[r][2])) [i, s] = V.cache[r]; else { let n = ei(r); i = new ut(t.compilerParams).generate(n), V.cache[r] = [i, s, t.compilerParams] } return es(this, i, e, t.runtimeParams, r) } V.cache = {}; V.compilerParams = { globalsNoObserve: [], globalsOnlyPaths: !1, compact: 2 }; V.runtimeParams = {}; V.cloneCache = {}; V.clone = function (e, t = null, r = {}, i = {}) {
        if (typeof e != "function") throw new Error(`Expected argument 1 to be of type 'function' but got ${typeof e}.`); if (!e.name) throw new Error("Function must have a name."); let s = Zr(e.toString(), !0), n = s, a; if (s.startsWith("async ") && (a = !0, n = n.substring(6)), !n.startsWith("function ") && !n.startsWith("function(")) { if (n.trim().startsWith("[")) { let h, f = n.split(/\](?:[\s]+)?\(/g).filter(m => m);[h, n] = f.reduce((m, p, g) => { if (Array.isArray(m)) return m; p = `${m}${p || ""}]`; try { return ei(p), [p, `${e.name}(${f.slice(g + 1).join("] (")}`] } catch { return `${p} (` } }, "") } n = "function " + n } let o, u, c; if (V.cloneCache[n] && !r.devMode && ri(r, V.cloneCache[n][3])) [o, u, c] = V.cloneCache[n]; else {
            let h = ei(n).body[0], f = h.body.start + 1; n.substr(f, 1) === `
`&& (f += 1); let m = new ut({ ...r, ...V.compilerParams, locStart: -f }); u = h.params.map(p => m.serialize(p)), o = m.generate({ type: "Program", body: h.body.body }), !o.graph.hoistedAwaitKeyword && a && (o.graph.hoistedAwaitKeyword = !0), c = n.substring(f, h.body.end - 1), V.cloneCache[n] = [o, u, c, r]
        } return es(t, o, u, i, c, e.name)
    }; var es = function (e, t, r = [], i = {}, s = null, n = null) { let a = wt.create(t, r, { ...i, ...V.runtimeParams }), o = function (...c) { try { return a.call(this === void 0 ? e : this, ...c) } catch (h) { throw console.info("-----------------------"), console.log(s || ""), console.info("-----------------------"), h } }; o.thread = a.thread.bind(a), o.dispose = a.dispose.bind(a), Object.defineProperty(o, "runtime", { value: a }), Object.defineProperty(o, "sideEffects", { configurable: !0, value: a.graph.sideEffects }), Object.defineProperty(o, "subscriptSource", { configurable: !0, value: t.source }), Object.defineProperty(o, "originalSource", { configurable: !0, value: s }), Object.defineProperty(o, "length", { configurable: !0, value: r.length }), Object.defineProperty(o, "name", { configurable: !0, value: n }); let u = (t.graph.hoistedAwaitKeyword ? "async " : "") + "function" + (n ? " " + n : ""); return o.toString = () => `${u}(${r.join(", ")}) {${s}}`, o }, Zi = new Map, ei = function (e, t = {}) { t = { ecmaVersion: "2020", allowReturnOutsideFunction: !0, allowAwaitOutsideFunction: !0, allowSuperOutsideMethod: !0, preserveParens: !1, ...t }; let r = Zi.get(e); return r || (r = ii.parse(e, t), Zi.set(e, r)), r }, ti = (e, t) => typeof e == "object" && e && typeof t == "object" && t ? ri(e, t) : Array.isArray(e) && Array.isArray(t) && e.length === t.length ? e.every(r => t.some(i => ti(r, i))) : e === t, ri = function (e, t) { for (let r in e) if (!ti(e[r], t[r])) return !1; return !0 }; var si = e => class extends (e || class { }) { static get compilerParams() { return {} } static get runtimeParams() { return {} } static get subscriptMethods() { return [] } static implementMethod(t, r = null) { return V.clone(t, r, this.compilerParams, this.runtimeParams) } constructor() { super(); let t = this.constructor; t.subscriptMethods.forEach(r => { if (!this[r]) throw new Error(`${r} is not a method.`); if (r === "constructor") throw new Error("Class constructors cannot be subscript methods."); this[r] = t.implementMethod(this[r], this) }) } }; var un = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239], ns = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], ln = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F", as = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", ni = { 3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile", 5: "class enum extends super const export import", 6: "enum", strict: "implements interface let package private protected public static yield", strictBind: "eval arguments" }, ai = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", cn = { 5: ai, "5module": ai + " export import", 6: ai + " const class extends export import super" }, hn = /^in(stanceof)?$/, fn = new RegExp("[" + as + "]"), pn = new RegExp("[" + as + ln + "]"); function ui(e, t) { for (var r = 65536, i = 0; i < t.length; i += 2) { if (r += t[i], r > e) return !1; if (r += t[i + 1], r >= e) return !0 } } function Le(e, t) { return e < 65 ? e === 36 : e < 91 ? !0 : e < 97 ? e === 95 : e < 123 ? !0 : e <= 65535 ? e >= 170 && fn.test(String.fromCharCode(e)) : t === !1 ? !1 : ui(e, ns) } function _t(e, t) { return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e < 91 ? !0 : e < 97 ? e === 95 : e < 123 ? !0 : e <= 65535 ? e >= 170 && pn.test(String.fromCharCode(e)) : t === !1 ? !1 : ui(e, ns) || ui(e, un) } var L = function (t, r) { r === void 0 && (r = {}), this.label = t, this.keyword = r.keyword, this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.isLoop = !!r.isLoop, this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop || null, this.updateContext = null }; function pe(e, t) { return new L(e, { beforeExpr: !0, binop: t }) } var me = { beforeExpr: !0 }, se = { startsExpr: !0 }, hi = {}; function F(e, t) { return t === void 0 && (t = {}), t.keyword = e, hi[e] = new L(e, t) } var l = { num: new L("num", se), regexp: new L("regexp", se), string: new L("string", se), name: new L("name", se), privateId: new L("privateId", se), eof: new L("eof"), bracketL: new L("[", { beforeExpr: !0, startsExpr: !0 }), bracketR: new L("]"), braceL: new L("{", { beforeExpr: !0, startsExpr: !0 }), braceR: new L("}"), parenL: new L("(", { beforeExpr: !0, startsExpr: !0 }), parenR: new L(")"), comma: new L(",", me), semi: new L(";", me), colon: new L(":", me), dot: new L("."), question: new L("?", me), questionDot: new L("?."), arrow: new L("=>", me), template: new L("template"), invalidTemplate: new L("invalidTemplate"), ellipsis: new L("...", me), backQuote: new L("`", se), dollarBraceL: new L("${", { beforeExpr: !0, startsExpr: !0 }), eq: new L("=", { beforeExpr: !0, isAssign: !0 }), assign: new L("_=", { beforeExpr: !0, isAssign: !0 }), incDec: new L("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }), prefix: new L("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), logicalOR: pe("||", 1), logicalAND: pe("&&", 2), bitwiseOR: pe("|", 3), bitwiseXOR: pe("^", 4), bitwiseAND: pe("&", 5), equality: pe("==/!=/===/!==", 6), relational: pe("</>/<=/>=", 7), bitShift: pe("<</>>/>>>", 8), plusMin: new L("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }), modulo: pe("%", 10), star: pe("*", 10), slash: pe("/", 10), starstar: new L("**", { beforeExpr: !0 }), coalesce: pe("??", 1), _break: F("break"), _case: F("case", me), _catch: F("catch"), _continue: F("continue"), _debugger: F("debugger"), _default: F("default", me), _do: F("do", { isLoop: !0, beforeExpr: !0 }), _else: F("else", me), _finally: F("finally"), _for: F("for", { isLoop: !0 }), _function: F("function", se), _if: F("if"), _return: F("return", me), _switch: F("switch"), _throw: F("throw", me), _try: F("try"), _var: F("var"), _const: F("const"), _while: F("while", { isLoop: !0 }), _with: F("with"), _new: F("new", { beforeExpr: !0, startsExpr: !0 }), _this: F("this", se), _super: F("super", se), _class: F("class", se), _extends: F("extends", me), _export: F("export"), _import: F("import", se), _null: F("null", se), _true: F("true", se), _false: F("false", se), _in: F("in", { beforeExpr: !0, binop: 7 }), _instanceof: F("instanceof", { beforeExpr: !0, binop: 7 }), _typeof: F("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), _void: F("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), _delete: F("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 }) }, ge = /\r\n?|\n|\u2028|\u2029/, mn = new RegExp(ge.source, "g"); function St(e) { return e === 10 || e === 13 || e === 8232 || e === 8233 } function os(e, t, r) { r === void 0 && (r = e.length); for (var i = t; i < r; i++) { var s = e.charCodeAt(i); if (St(s)) return i < r - 1 && s === 13 && e.charCodeAt(i + 1) === 10 ? i + 2 : i + 1 } return -1 } var us = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, de = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, ls = Object.prototype, dn = ls.hasOwnProperty, gn = ls.toString, jt = Object.hasOwn || function (e, t) { return dn.call(e, t) }, ts = Array.isArray || function (e) { return gn.call(e) === "[object Array]" }; function lt(e) { return new RegExp("^(?:" + e.replace(/ /g, "|") + ")$") } function Ge(e) { return e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10) + 55296, (e & 1023) + 56320)) } var xn = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, Dt = function (t, r) { this.line = t, this.column = r }; Dt.prototype.offset = function (t) { return new Dt(this.line, this.column + t) }; var kr = function (t, r, i) { this.start = r, this.end = i, t.sourceFile !== null && (this.source = t.sourceFile) }; function cs(e, t) { for (var r = 1, i = 0; ;) { var s = os(e, i, t); if (s < 0) return new Dt(r, t - i); ++r, i = s } } var li = { ecmaVersion: null, sourceType: "script", onInsertedSemicolon: null, onTrailingComma: null, allowReserved: null, allowReturnOutsideFunction: !1, allowImportExportEverywhere: !1, allowAwaitOutsideFunction: null, allowSuperOutsideMethod: null, allowHashBang: !1, locations: !1, onToken: null, onComment: null, ranges: !1, program: null, sourceFile: null, directSourceFile: null, preserveParens: !1 }, rs = !1; function bn(e) {
        var t = {}; for (var r in li) t[r] = e && jt(e, r) ? e[r] : li[r]; if (t.ecmaVersion === "latest" ? t.ecmaVersion = 1e8 : t.ecmaVersion == null ? (!rs && typeof console == "object" && console.warn && (rs = !0, console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)), t.ecmaVersion = 11) : t.ecmaVersion >= 2015 && (t.ecmaVersion -= 2009), t.allowReserved == null && (t.allowReserved = t.ecmaVersion < 5), ts(t.onToken)) { var i = t.onToken; t.onToken = function (s) { return i.push(s) } } return ts(t.onComment) && (t.onComment = yn(t, t.onComment)), t
    } function yn(e, t) { return function (r, i, s, n, a, o) { var u = { type: r ? "Block" : "Line", value: i, start: s, end: n }; e.locations && (u.loc = new kr(this, a, o)), e.ranges && (u.range = [s, n]), t.push(u) } } var Bt = 1, Et = 2, fi = 4, hs = 8, fs = 16, ps = 32, pi = 64, ms = 128, qt = 256, mi = Bt | Et | qt; function di(e, t) { return Et | (e ? fi : 0) | (t ? hs : 0) } var Sr = 0, gi = 1, Fe = 2, ds = 3, gs = 4, xs = 5, W = function (t, r, i) {
        this.options = t = bn(t), this.sourceFile = t.sourceFile, this.keywords = lt(cn[t.ecmaVersion >= 6 ? 6 : t.sourceType === "module" ? "5module" : 5]); var s = ""; t.allowReserved !== !0 && (s = ni[t.ecmaVersion >= 6 ? 6 : t.ecmaVersion === 5 ? 5 : 3], t.sourceType === "module" && (s += " await")), this.reservedWords = lt(s); var n = (s ? s + " " : "") + ni.strict; this.reservedWordsStrict = lt(n), this.reservedWordsStrictBind = lt(n + " " + ni.strictBind), this.input = String(r), this.containsEsc = !1, i ? (this.pos = i, this.lineStart = this.input.lastIndexOf(`
`, i - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(ge).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = l.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = t.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = !1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = Object.create(null), this.pos === 0 && t.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(Bt), this.regexpState = null, this.privateNameStack = []
    }, Pe = { inFunction: { configurable: !0 }, inGenerator: { configurable: !0 }, inAsync: { configurable: !0 }, canAwait: { configurable: !0 }, allowSuper: { configurable: !0 }, allowDirectSuper: { configurable: !0 }, treatFunctionsAsVar: { configurable: !0 }, allowNewDotTarget: { configurable: !0 }, inClassStaticBlock: { configurable: !0 } }; W.prototype.parse = function () { var t = this.options.program || this.startNode(); return this.nextToken(), this.parseTopLevel(t) }; Pe.inFunction.get = function () { return (this.currentVarScope().flags & Et) > 0 }; Pe.inGenerator.get = function () { return (this.currentVarScope().flags & hs) > 0 && !this.currentVarScope().inClassFieldInit }; Pe.inAsync.get = function () { return (this.currentVarScope().flags & fi) > 0 && !this.currentVarScope().inClassFieldInit }; Pe.canAwait.get = function () { for (var e = this.scopeStack.length - 1; e >= 0; e--) { var t = this.scopeStack[e]; if (t.inClassFieldInit || t.flags & qt) return !1; if (t.flags & Et) return (t.flags & fi) > 0 } return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction }; Pe.allowSuper.get = function () { var e = this.currentThisScope(), t = e.flags, r = e.inClassFieldInit; return (t & pi) > 0 || r || this.options.allowSuperOutsideMethod }; Pe.allowDirectSuper.get = function () { return (this.currentThisScope().flags & ms) > 0 }; Pe.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) }; Pe.allowNewDotTarget.get = function () { var e = this.currentThisScope(), t = e.flags, r = e.inClassFieldInit; return (t & (Et | qt)) > 0 || r }; Pe.inClassStaticBlock.get = function () { return (this.currentVarScope().flags & qt) > 0 }; W.extend = function () { for (var t = [], r = arguments.length; r--;)t[r] = arguments[r]; for (var i = this, s = 0; s < t.length; s++)i = t[s](i); return i }; W.parse = function (t, r) { return new this(r, t).parse() }; W.parseExpressionAt = function (t, r, i) { var s = new this(i, t, r); return s.nextToken(), s.parseExpression() }; W.tokenizer = function (t, r) { return new this(r, t) }; Object.defineProperties(W.prototype, Pe); var re = W.prototype, vn = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/; re.strictDirective = function (e) { if (this.options.ecmaVersion < 5) return !1; for (; ;) { de.lastIndex = e, e += de.exec(this.input)[0].length; var t = vn.exec(this.input.slice(e)); if (!t) return !1; if ((t[1] || t[2]) === "use strict") { de.lastIndex = e + t[0].length; var r = de.exec(this.input), i = r.index + r[0].length, s = this.input.charAt(i); return s === ";" || s === "}" || ge.test(r[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(s) || s === "!" && this.input.charAt(i + 1) === "=") } e += t[0].length, de.lastIndex = e, e += de.exec(this.input)[0].length, this.input[e] === ";" && e++ } }; re.eat = function (e) { return this.type === e ? (this.next(), !0) : !1 }; re.isContextual = function (e) { return this.type === l.name && this.value === e && !this.containsEsc }; re.eatContextual = function (e) { return this.isContextual(e) ? (this.next(), !0) : !1 }; re.expectContextual = function (e) { this.eatContextual(e) || this.unexpected() }; re.canInsertSemicolon = function () { return this.type === l.eof || this.type === l.braceR || ge.test(this.input.slice(this.lastTokEnd, this.start)) }; re.insertSemicolon = function () { if (this.canInsertSemicolon()) return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0 }; re.semicolon = function () { !this.eat(l.semi) && !this.insertSemicolon() && this.unexpected() }; re.afterTrailingComma = function (e, t) { if (this.type === e) return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), t || this.next(), !0 }; re.expect = function (e) { this.eat(e) || this.unexpected() }; re.unexpected = function (e) { this.raise(e ?? this.start, "Unexpected token") }; var Ar = function () { this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1 }; re.checkPatternErrors = function (e, t) { if (!!e) { e.trailingComma > -1 && this.raiseRecoverable(e.trailingComma, "Comma is not permitted after the rest element"); var r = t ? e.parenthesizedAssign : e.parenthesizedBind; r > -1 && this.raiseRecoverable(r, "Parenthesized pattern") } }; re.checkExpressionErrors = function (e, t) { if (!e) return !1; var r = e.shorthandAssign, i = e.doubleProto; if (!t) return r >= 0 || i >= 0; r >= 0 && this.raise(r, "Shorthand property assignments are valid only in destructuring patterns"), i >= 0 && this.raiseRecoverable(i, "Redefinition of __proto__ property") }; re.checkYieldAwaitInDefaultParams = function () { this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value") }; re.isSimpleAssignTarget = function (e) { return e.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(e.expression) : e.type === "Identifier" || e.type === "MemberExpression" }; var C = W.prototype; C.parseTopLevel = function (e) { var t = Object.create(null); for (e.body || (e.body = []); this.type !== l.eof;) { var r = this.parseStatement(null, !0, t); e.body.push(r) } if (this.inModule) for (var i = 0, s = Object.keys(this.undefinedExports); i < s.length; i += 1) { var n = s[i]; this.raiseRecoverable(this.undefinedExports[n].start, "Export '" + n + "' is not defined") } return this.adaptDirectivePrologue(e.body), this.next(), e.sourceType = this.options.sourceType, this.finishNode(e, "Program") }; var xi = { kind: "loop" }, wn = { kind: "switch" }; C.isLet = function (e) { if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return !1; de.lastIndex = this.pos; var t = de.exec(this.input), r = this.pos + t[0].length, i = this.input.charCodeAt(r); if (i === 91 || i === 92 || i > 55295 && i < 56320) return !0; if (e) return !1; if (i === 123) return !0; if (Le(i, !0)) { for (var s = r + 1; _t(i = this.input.charCodeAt(s), !0);)++s; if (i === 92 || i > 55295 && i < 56320) return !0; var n = this.input.slice(r, s); if (!hn.test(n)) return !0 } return !1 }; C.isAsyncFunction = function () { if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return !1; de.lastIndex = this.pos; var e = de.exec(this.input), t = this.pos + e[0].length, r; return !ge.test(this.input.slice(this.pos, t)) && this.input.slice(t, t + 8) === "function" && (t + 8 === this.input.length || !(_t(r = this.input.charCodeAt(t + 8)) || r > 55295 && r < 56320)) }; C.parseStatement = function (e, t, r) { var i = this.type, s = this.startNode(), n; switch (this.isLet(e) && (i = l._var, n = "let"), i) { case l._break: case l._continue: return this.parseBreakContinueStatement(s, i.keyword); case l._debugger: return this.parseDebuggerStatement(s); case l._do: return this.parseDoStatement(s); case l._for: return this.parseForStatement(s); case l._function: return e && (this.strict || e !== "if" && e !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(s, !1, !e); case l._class: return e && this.unexpected(), this.parseClass(s, !0); case l._if: return this.parseIfStatement(s); case l._return: return this.parseReturnStatement(s); case l._switch: return this.parseSwitchStatement(s); case l._throw: return this.parseThrowStatement(s); case l._try: return this.parseTryStatement(s); case l._const: case l._var: return n = n || this.value, e && n !== "var" && this.unexpected(), this.parseVarStatement(s, n); case l._while: return this.parseWhileStatement(s); case l._with: return this.parseWithStatement(s); case l.braceL: return this.parseBlock(!0, s); case l.semi: return this.parseEmptyStatement(s); case l._export: case l._import: if (this.options.ecmaVersion > 10 && i === l._import) { de.lastIndex = this.pos; var a = de.exec(this.input), o = this.pos + a[0].length, u = this.input.charCodeAt(o); if (u === 40 || u === 46) return this.parseExpressionStatement(s, this.parseExpression()) } return this.options.allowImportExportEverywhere || (t || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), i === l._import ? this.parseImport(s) : this.parseExport(s, r); default: if (this.isAsyncFunction()) return e && this.unexpected(), this.next(), this.parseFunctionStatement(s, !0, !e); var c = this.value, h = this.parseExpression(); return i === l.name && h.type === "Identifier" && this.eat(l.colon) ? this.parseLabeledStatement(s, c, h, e) : this.parseExpressionStatement(s, h) } }; C.parseBreakContinueStatement = function (e, t) { var r = t === "break"; this.next(), this.eat(l.semi) || this.insertSemicolon() ? e.label = null : this.type !== l.name ? this.unexpected() : (e.label = this.parseIdent(), this.semicolon()); for (var i = 0; i < this.labels.length; ++i) { var s = this.labels[i]; if ((e.label == null || s.name === e.label.name) && (s.kind != null && (r || s.kind === "loop") || e.label && r)) break } return i === this.labels.length && this.raise(e.start, "Unsyntactic " + t), this.finishNode(e, r ? "BreakStatement" : "ContinueStatement") }; C.parseDebuggerStatement = function (e) { return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement") }; C.parseDoStatement = function (e) { return this.next(), this.labels.push(xi), e.body = this.parseStatement("do"), this.labels.pop(), this.expect(l._while), e.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(l.semi) : this.semicolon(), this.finishNode(e, "DoWhileStatement") }; C.parseForStatement = function (e) { this.next(); var t = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1; if (this.labels.push(xi), this.enterScope(0), this.expect(l.parenL), this.type === l.semi) return t > -1 && this.unexpected(t), this.parseFor(e, null); var r = this.isLet(); if (this.type === l._var || this.type === l._const || r) { var i = this.startNode(), s = r ? "let" : this.value; return this.next(), this.parseVar(i, !0, s), this.finishNode(i, "VariableDeclaration"), (this.type === l._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && i.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === l._in ? t > -1 && this.unexpected(t) : e.await = t > -1), this.parseForIn(e, i)) : (t > -1 && this.unexpected(t), this.parseFor(e, i)) } var n = this.isContextual("let"), a = !1, o = new Ar, u = this.parseExpression(t > -1 ? "await" : !0, o); return this.type === l._in || (a = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (this.options.ecmaVersion >= 9 && (this.type === l._in ? t > -1 && this.unexpected(t) : e.await = t > -1), n && a && this.raise(u.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(u, !1, o), this.checkLValPattern(u), this.parseForIn(e, u)) : (this.checkExpressionErrors(o, !0), t > -1 && this.unexpected(t), this.parseFor(e, u)) }; C.parseFunctionStatement = function (e, t, r) { return this.next(), this.parseFunction(e, Vt | (r ? 0 : ci), !1, t) }; C.parseIfStatement = function (e) { return this.next(), e.test = this.parseParenExpression(), e.consequent = this.parseStatement("if"), e.alternate = this.eat(l._else) ? this.parseStatement("if") : null, this.finishNode(e, "IfStatement") }; C.parseReturnStatement = function (e) { return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(), this.eat(l.semi) || this.insertSemicolon() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "ReturnStatement") }; C.parseSwitchStatement = function (e) { this.next(), e.discriminant = this.parseParenExpression(), e.cases = [], this.expect(l.braceL), this.labels.push(wn), this.enterScope(0); for (var t, r = !1; this.type !== l.braceR;)if (this.type === l._case || this.type === l._default) { var i = this.type === l._case; t && this.finishNode(t, "SwitchCase"), e.cases.push(t = this.startNode()), t.consequent = [], this.next(), i ? t.test = this.parseExpression() : (r && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), r = !0, t.test = null), this.expect(l.colon) } else t || this.unexpected(), t.consequent.push(this.parseStatement(null)); return this.exitScope(), t && this.finishNode(t, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(e, "SwitchStatement") }; C.parseThrowStatement = function (e) { return this.next(), ge.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), e.argument = this.parseExpression(), this.semicolon(), this.finishNode(e, "ThrowStatement") }; var _n = []; C.parseTryStatement = function (e) { if (this.next(), e.block = this.parseBlock(), e.handler = null, this.type === l._catch) { var t = this.startNode(); if (this.next(), this.eat(l.parenL)) { t.param = this.parseBindingAtom(); var r = t.param.type === "Identifier"; this.enterScope(r ? ps : 0), this.checkLValPattern(t.param, r ? gs : Fe), this.expect(l.parenR) } else this.options.ecmaVersion < 10 && this.unexpected(), t.param = null, this.enterScope(0); t.body = this.parseBlock(!1), this.exitScope(), e.handler = this.finishNode(t, "CatchClause") } return e.finalizer = this.eat(l._finally) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(e.start, "Missing catch or finally clause"), this.finishNode(e, "TryStatement") }; C.parseVarStatement = function (e, t) { return this.next(), this.parseVar(e, !1, t), this.semicolon(), this.finishNode(e, "VariableDeclaration") }; C.parseWhileStatement = function (e) { return this.next(), e.test = this.parseParenExpression(), this.labels.push(xi), e.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(e, "WhileStatement") }; C.parseWithStatement = function (e) { return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), e.object = this.parseParenExpression(), e.body = this.parseStatement("with"), this.finishNode(e, "WithStatement") }; C.parseEmptyStatement = function (e) { return this.next(), this.finishNode(e, "EmptyStatement") }; C.parseLabeledStatement = function (e, t, r, i) { for (var s = 0, n = this.labels; s < n.length; s += 1) { var a = n[s]; a.name === t && this.raise(r.start, "Label '" + t + "' is already declared") } for (var o = this.type.isLoop ? "loop" : this.type === l._switch ? "switch" : null, u = this.labels.length - 1; u >= 0; u--) { var c = this.labels[u]; if (c.statementStart === e.start) c.statementStart = this.start, c.kind = o; else break } return this.labels.push({ name: t, kind: o, statementStart: this.start }), e.body = this.parseStatement(i ? i.indexOf("label") === -1 ? i + "label" : i : "label"), this.labels.pop(), e.label = r, this.finishNode(e, "LabeledStatement") }; C.parseExpressionStatement = function (e, t) { return e.expression = t, this.semicolon(), this.finishNode(e, "ExpressionStatement") }; C.parseBlock = function (e, t, r) { for (e === void 0 && (e = !0), t === void 0 && (t = this.startNode()), t.body = [], this.expect(l.braceL), e && this.enterScope(0); this.type !== l.braceR;) { var i = this.parseStatement(null); t.body.push(i) } return r && (this.strict = !1), this.next(), e && this.exitScope(), this.finishNode(t, "BlockStatement") }; C.parseFor = function (e, t) { return e.init = t, this.expect(l.semi), e.test = this.type === l.semi ? null : this.parseExpression(), this.expect(l.semi), e.update = this.type === l.parenR ? null : this.parseExpression(), this.expect(l.parenR), e.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e, "ForStatement") }; C.parseForIn = function (e, t) { var r = this.type === l._in; return this.next(), t.type === "VariableDeclaration" && t.declarations[0].init != null && (!r || this.options.ecmaVersion < 8 || this.strict || t.kind !== "var" || t.declarations[0].id.type !== "Identifier") && this.raise(t.start, (r ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"), e.left = t, e.right = r ? this.parseExpression() : this.parseMaybeAssign(), this.expect(l.parenR), e.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e, r ? "ForInStatement" : "ForOfStatement") }; C.parseVar = function (e, t, r) { for (e.declarations = [], e.kind = r; ;) { var i = this.startNode(); if (this.parseVarId(i, r), this.eat(l.eq) ? i.init = this.parseMaybeAssign(t) : r === "const" && !(this.type === l._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : i.id.type !== "Identifier" && !(t && (this.type === l._in || this.isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : i.init = null, e.declarations.push(this.finishNode(i, "VariableDeclarator")), !this.eat(l.comma)) break } return e }; C.parseVarId = function (e, t) { e.id = this.parseBindingAtom(), this.checkLValPattern(e.id, t === "var" ? gi : Fe, !1) }; var Vt = 1, ci = 2, bs = 4; C.parseFunction = function (e, t, r, i, s) { this.initFunction(e), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !i) && (this.type === l.star && t & ci && this.unexpected(), e.generator = this.eat(l.star)), this.options.ecmaVersion >= 8 && (e.async = !!i), t & Vt && (e.id = t & bs && this.type !== l.name ? null : this.parseIdent(), e.id && !(t & ci) && this.checkLValSimple(e.id, this.strict || e.generator || e.async ? this.treatFunctionsAsVar ? gi : Fe : ds)); var n = this.yieldPos, a = this.awaitPos, o = this.awaitIdentPos; return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(di(e.async, e.generator)), t & Vt || (e.id = this.type === l.name ? this.parseIdent() : null), this.parseFunctionParams(e), this.parseFunctionBody(e, r, !1, s), this.yieldPos = n, this.awaitPos = a, this.awaitIdentPos = o, this.finishNode(e, t & Vt ? "FunctionDeclaration" : "FunctionExpression") }; C.parseFunctionParams = function (e) { this.expect(l.parenL), e.params = this.parseBindingList(l.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams() }; C.parseClass = function (e, t) { this.next(); var r = this.strict; this.strict = !0, this.parseClassId(e, t), this.parseClassSuper(e); var i = this.enterClassBody(), s = this.startNode(), n = !1; for (s.body = [], this.expect(l.braceL); this.type !== l.braceR;) { var a = this.parseClassElement(e.superClass !== null); a && (s.body.push(a), a.type === "MethodDefinition" && a.kind === "constructor" ? (n && this.raise(a.start, "Duplicate constructor in the same class"), n = !0) : a.key && a.key.type === "PrivateIdentifier" && Sn(i, a) && this.raiseRecoverable(a.key.start, "Identifier '#" + a.key.name + "' has already been declared")) } return this.strict = r, this.next(), e.body = this.finishNode(s, "ClassBody"), this.exitClassBody(), this.finishNode(e, t ? "ClassDeclaration" : "ClassExpression") }; C.parseClassElement = function (e) { if (this.eat(l.semi)) return null; var t = this.options.ecmaVersion, r = this.startNode(), i = "", s = !1, n = !1, a = "method", o = !1; if (this.eatContextual("static")) { if (t >= 13 && this.eat(l.braceL)) return this.parseClassStaticBlock(r), r; this.isClassElementNameStart() || this.type === l.star ? o = !0 : i = "static" } if (r.static = o, !i && t >= 8 && this.eatContextual("async") && ((this.isClassElementNameStart() || this.type === l.star) && !this.canInsertSemicolon() ? n = !0 : i = "async"), !i && (t >= 9 || !n) && this.eat(l.star) && (s = !0), !i && !n && !s) { var u = this.value; (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? a = u : i = u) } if (i ? (r.computed = !1, r.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), r.key.name = i, this.finishNode(r.key, "Identifier")) : this.parseClassElementName(r), t < 13 || this.type === l.parenL || a !== "method" || s || n) { var c = !r.static && Er(r, "constructor"), h = c && e; c && a !== "method" && this.raise(r.key.start, "Constructor can't have get/set modifier"), r.kind = c ? "constructor" : a, this.parseClassMethod(r, s, n, h) } else this.parseClassField(r); return r }; C.isClassElementNameStart = function () { return this.type === l.name || this.type === l.privateId || this.type === l.num || this.type === l.string || this.type === l.bracketL || this.type.keyword }; C.parseClassElementName = function (e) { this.type === l.privateId ? (this.value === "constructor" && this.raise(this.start, "Classes can't have an element named '#constructor'"), e.computed = !1, e.key = this.parsePrivateIdent()) : this.parsePropertyName(e) }; C.parseClassMethod = function (e, t, r, i) { var s = e.key; e.kind === "constructor" ? (t && this.raise(s.start, "Constructor can't be a generator"), r && this.raise(s.start, "Constructor can't be an async method")) : e.static && Er(e, "prototype") && this.raise(s.start, "Classes may not have a static property named prototype"); var n = e.value = this.parseMethod(t, r, i); return e.kind === "get" && n.params.length !== 0 && this.raiseRecoverable(n.start, "getter should have no params"), e.kind === "set" && n.params.length !== 1 && this.raiseRecoverable(n.start, "setter should have exactly one param"), e.kind === "set" && n.params[0].type === "RestElement" && this.raiseRecoverable(n.params[0].start, "Setter cannot use rest params"), this.finishNode(e, "MethodDefinition") }; C.parseClassField = function (e) { if (Er(e, "constructor") ? this.raise(e.key.start, "Classes can't have a field named 'constructor'") : e.static && Er(e, "prototype") && this.raise(e.key.start, "Classes can't have a static field named 'prototype'"), this.eat(l.eq)) { var t = this.currentThisScope(), r = t.inClassFieldInit; t.inClassFieldInit = !0, e.value = this.parseMaybeAssign(), t.inClassFieldInit = r } else e.value = null; return this.semicolon(), this.finishNode(e, "PropertyDefinition") }; C.parseClassStaticBlock = function (e) { e.body = []; var t = this.labels; for (this.labels = [], this.enterScope(qt | pi); this.type !== l.braceR;) { var r = this.parseStatement(null); e.body.push(r) } return this.next(), this.exitScope(), this.labels = t, this.finishNode(e, "StaticBlock") }; C.parseClassId = function (e, t) { this.type === l.name ? (e.id = this.parseIdent(), t && this.checkLValSimple(e.id, Fe, !1)) : (t === !0 && this.unexpected(), e.id = null) }; C.parseClassSuper = function (e) { e.superClass = this.eat(l._extends) ? this.parseExprSubscripts(!1) : null }; C.enterClassBody = function () { var e = { declared: Object.create(null), used: [] }; return this.privateNameStack.push(e), e.declared }; C.exitClassBody = function () { for (var e = this.privateNameStack.pop(), t = e.declared, r = e.used, i = this.privateNameStack.length, s = i === 0 ? null : this.privateNameStack[i - 1], n = 0; n < r.length; ++n) { var a = r[n]; jt(t, a.name) || (s ? s.used.push(a) : this.raiseRecoverable(a.start, "Private field '#" + a.name + "' must be declared in an enclosing class")) } }; function Sn(e, t) { var r = t.key.name, i = e[r], s = "true"; return t.type === "MethodDefinition" && (t.kind === "get" || t.kind === "set") && (s = (t.static ? "s" : "i") + t.kind), i === "iget" && s === "iset" || i === "iset" && s === "iget" || i === "sget" && s === "sset" || i === "sset" && s === "sget" ? (e[r] = "true", !1) : i ? !0 : (e[r] = s, !1) } function Er(e, t) { var r = e.computed, i = e.key; return !r && (i.type === "Identifier" && i.name === t || i.type === "Literal" && i.value === t) } C.parseExport = function (e, t) { if (this.next(), this.eat(l.star)) return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (e.exported = this.parseModuleExportName(), this.checkExport(t, e.exported, this.lastTokStart)) : e.exported = null), this.expectContextual("from"), this.type !== l.string && this.unexpected(), e.source = this.parseExprAtom(), this.semicolon(), this.finishNode(e, "ExportAllDeclaration"); if (this.eat(l._default)) { this.checkExport(t, "default", this.lastTokStart); var r; if (this.type === l._function || (r = this.isAsyncFunction())) { var i = this.startNode(); this.next(), r && this.next(), e.declaration = this.parseFunction(i, Vt | bs, !1, r) } else if (this.type === l._class) { var s = this.startNode(); e.declaration = this.parseClass(s, "nullableID") } else e.declaration = this.parseMaybeAssign(), this.semicolon(); return this.finishNode(e, "ExportDefaultDeclaration") } if (this.shouldParseExportStatement()) e.declaration = this.parseStatement(null), e.declaration.type === "VariableDeclaration" ? this.checkVariableExport(t, e.declaration.declarations) : this.checkExport(t, e.declaration.id, e.declaration.id.start), e.specifiers = [], e.source = null; else { if (e.declaration = null, e.specifiers = this.parseExportSpecifiers(t), this.eatContextual("from")) this.type !== l.string && this.unexpected(), e.source = this.parseExprAtom(); else { for (var n = 0, a = e.specifiers; n < a.length; n += 1) { var o = a[n]; this.checkUnreserved(o.local), this.checkLocalExport(o.local), o.local.type === "Literal" && this.raise(o.local.start, "A string literal cannot be used as an exported binding without `from`.") } e.source = null } this.semicolon() } return this.finishNode(e, "ExportNamedDeclaration") }; C.checkExport = function (e, t, r) { !e || (typeof t != "string" && (t = t.type === "Identifier" ? t.name : t.value), jt(e, t) && this.raiseRecoverable(r, "Duplicate export '" + t + "'"), e[t] = !0) }; C.checkPatternExport = function (e, t) { var r = t.type; if (r === "Identifier") this.checkExport(e, t, t.start); else if (r === "ObjectPattern") for (var i = 0, s = t.properties; i < s.length; i += 1) { var n = s[i]; this.checkPatternExport(e, n) } else if (r === "ArrayPattern") for (var a = 0, o = t.elements; a < o.length; a += 1) { var u = o[a]; u && this.checkPatternExport(e, u) } else r === "Property" ? this.checkPatternExport(e, t.value) : r === "AssignmentPattern" ? this.checkPatternExport(e, t.left) : r === "RestElement" ? this.checkPatternExport(e, t.argument) : r === "ParenthesizedExpression" && this.checkPatternExport(e, t.expression) }; C.checkVariableExport = function (e, t) { if (!!e) for (var r = 0, i = t; r < i.length; r += 1) { var s = i[r]; this.checkPatternExport(e, s.id) } }; C.shouldParseExportStatement = function () { return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction() }; C.parseExportSpecifiers = function (e) { var t = [], r = !0; for (this.expect(l.braceL); !this.eat(l.braceR);) { if (r) r = !1; else if (this.expect(l.comma), this.afterTrailingComma(l.braceR)) break; var i = this.startNode(); i.local = this.parseModuleExportName(), i.exported = this.eatContextual("as") ? this.parseModuleExportName() : i.local, this.checkExport(e, i.exported, i.exported.start), t.push(this.finishNode(i, "ExportSpecifier")) } return t }; C.parseImport = function (e) { return this.next(), this.type === l.string ? (e.specifiers = _n, e.source = this.parseExprAtom()) : (e.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), e.source = this.type === l.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(e, "ImportDeclaration") }; C.parseImportSpecifiers = function () { var e = [], t = !0; if (this.type === l.name) { var r = this.startNode(); if (r.local = this.parseIdent(), this.checkLValSimple(r.local, Fe), e.push(this.finishNode(r, "ImportDefaultSpecifier")), !this.eat(l.comma)) return e } if (this.type === l.star) { var i = this.startNode(); return this.next(), this.expectContextual("as"), i.local = this.parseIdent(), this.checkLValSimple(i.local, Fe), e.push(this.finishNode(i, "ImportNamespaceSpecifier")), e } for (this.expect(l.braceL); !this.eat(l.braceR);) { if (t) t = !1; else if (this.expect(l.comma), this.afterTrailingComma(l.braceR)) break; var s = this.startNode(); s.imported = this.parseModuleExportName(), this.eatContextual("as") ? s.local = this.parseIdent() : (this.checkUnreserved(s.imported), s.local = s.imported), this.checkLValSimple(s.local, Fe), e.push(this.finishNode(s, "ImportSpecifier")) } return e }; C.parseModuleExportName = function () { if (this.options.ecmaVersion >= 13 && this.type === l.string) { var e = this.parseLiteral(this.value); return xn.test(e.value) && this.raise(e.start, "An export name cannot include a lone surrogate."), e } return this.parseIdent(!0) }; C.adaptDirectivePrologue = function (e) { for (var t = 0; t < e.length && this.isDirectiveCandidate(e[t]); ++t)e[t].directive = e[t].expression.raw.slice(1, -1) }; C.isDirectiveCandidate = function (e) { return e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value == "string" && (this.input[e.start] === '"' || this.input[e.start] === "'") }; var Se = W.prototype; Se.toAssignable = function (e, t, r) { if (this.options.ecmaVersion >= 6 && e) switch (e.type) { case "Identifier": this.inAsync && e.name === "await" && this.raise(e.start, "Cannot use 'await' as identifier inside an async function"); break; case "ObjectPattern": case "ArrayPattern": case "AssignmentPattern": case "RestElement": break; case "ObjectExpression": e.type = "ObjectPattern", r && this.checkPatternErrors(r, !0); for (var i = 0, s = e.properties; i < s.length; i += 1) { var n = s[i]; this.toAssignable(n, t), n.type === "RestElement" && (n.argument.type === "ArrayPattern" || n.argument.type === "ObjectPattern") && this.raise(n.argument.start, "Unexpected token") } break; case "Property": e.kind !== "init" && this.raise(e.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(e.value, t); break; case "ArrayExpression": e.type = "ArrayPattern", r && this.checkPatternErrors(r, !0), this.toAssignableList(e.elements, t); break; case "SpreadElement": e.type = "RestElement", this.toAssignable(e.argument, t), e.argument.type === "AssignmentPattern" && this.raise(e.argument.start, "Rest elements cannot have a default value"); break; case "AssignmentExpression": e.operator !== "=" && this.raise(e.left.end, "Only '=' operator can be used for specifying default value."), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(e.left, t); break; case "ParenthesizedExpression": this.toAssignable(e.expression, t, r); break; case "ChainExpression": this.raiseRecoverable(e.start, "Optional chaining cannot appear in left-hand side"); break; case "MemberExpression": if (!t) break; default: this.raise(e.start, "Assigning to rvalue") } else r && this.checkPatternErrors(r, !0); return e }; Se.toAssignableList = function (e, t) { for (var r = e.length, i = 0; i < r; i++) { var s = e[i]; s && this.toAssignable(s, t) } if (r) { var n = e[r - 1]; this.options.ecmaVersion === 6 && t && n && n.type === "RestElement" && n.argument.type !== "Identifier" && this.unexpected(n.argument.start) } return e }; Se.parseSpread = function (e) { var t = this.startNode(); return this.next(), t.argument = this.parseMaybeAssign(!1, e), this.finishNode(t, "SpreadElement") }; Se.parseRestBinding = function () { var e = this.startNode(); return this.next(), this.options.ecmaVersion === 6 && this.type !== l.name && this.unexpected(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement") }; Se.parseBindingAtom = function () { if (this.options.ecmaVersion >= 6) switch (this.type) { case l.bracketL: var e = this.startNode(); return this.next(), e.elements = this.parseBindingList(l.bracketR, !0, !0), this.finishNode(e, "ArrayPattern"); case l.braceL: return this.parseObj(!0) }return this.parseIdent() }; Se.parseBindingList = function (e, t, r) { for (var i = [], s = !0; !this.eat(e);)if (s ? s = !1 : this.expect(l.comma), t && this.type === l.comma) i.push(null); else { if (r && this.afterTrailingComma(e)) break; if (this.type === l.ellipsis) { var n = this.parseRestBinding(); this.parseBindingListItem(n), i.push(n), this.type === l.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.expect(e); break } else { var a = this.parseMaybeDefault(this.start, this.startLoc); this.parseBindingListItem(a), i.push(a) } } return i }; Se.parseBindingListItem = function (e) { return e }; Se.parseMaybeDefault = function (e, t, r) { if (r = r || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(l.eq)) return r; var i = this.startNodeAt(e, t); return i.left = r, i.right = this.parseMaybeAssign(), this.finishNode(i, "AssignmentPattern") }; Se.checkLValSimple = function (e, t, r) { t === void 0 && (t = Sr); var i = t !== Sr; switch (e.type) { case "Identifier": this.strict && this.reservedWordsStrictBind.test(e.name) && this.raiseRecoverable(e.start, (i ? "Binding " : "Assigning to ") + e.name + " in strict mode"), i && (t === Fe && e.name === "let" && this.raiseRecoverable(e.start, "let is disallowed as a lexically bound name"), r && (jt(r, e.name) && this.raiseRecoverable(e.start, "Argument name clash"), r[e.name] = !0), t !== xs && this.declareName(e.name, t, e.start)); break; case "ChainExpression": this.raiseRecoverable(e.start, "Optional chaining cannot appear in left-hand side"); break; case "MemberExpression": i && this.raiseRecoverable(e.start, "Binding member expression"); break; case "ParenthesizedExpression": return i && this.raiseRecoverable(e.start, "Binding parenthesized expression"), this.checkLValSimple(e.expression, t, r); default: this.raise(e.start, (i ? "Binding" : "Assigning to") + " rvalue") } }; Se.checkLValPattern = function (e, t, r) { switch (t === void 0 && (t = Sr), e.type) { case "ObjectPattern": for (var i = 0, s = e.properties; i < s.length; i += 1) { var n = s[i]; this.checkLValInnerPattern(n, t, r) } break; case "ArrayPattern": for (var a = 0, o = e.elements; a < o.length; a += 1) { var u = o[a]; u && this.checkLValInnerPattern(u, t, r) } break; default: this.checkLValSimple(e, t, r) } }; Se.checkLValInnerPattern = function (e, t, r) { switch (t === void 0 && (t = Sr), e.type) { case "Property": this.checkLValInnerPattern(e.value, t, r); break; case "AssignmentPattern": this.checkLValPattern(e.left, t, r); break; case "RestElement": this.checkLValPattern(e.argument, t, r); break; default: this.checkLValPattern(e, t, r) } }; var _e = function (t, r, i, s, n) { this.token = t, this.isExpr = !!r, this.preserveSpace = !!i, this.override = s, this.generator = !!n }, D = { b_stat: new _e("{", !1), b_expr: new _e("{", !0), b_tmpl: new _e("${", !1), p_stat: new _e("(", !1), p_expr: new _e("(", !0), q_tmpl: new _e("`", !0, !0, function (e) { return e.tryReadTemplateToken() }), f_stat: new _e("function", !1), f_expr: new _e("function", !0), f_expr_gen: new _e("function", !0, !1, null, !0), f_gen: new _e("function", !1, !1, null, !0) }, Ct = W.prototype; Ct.initialContext = function () { return [D.b_stat] }; Ct.curContext = function () { return this.context[this.context.length - 1] }; Ct.braceIsBlock = function (e) { var t = this.curContext(); return t === D.f_expr || t === D.f_stat ? !0 : e === l.colon && (t === D.b_stat || t === D.b_expr) ? !t.isExpr : e === l._return || e === l.name && this.exprAllowed ? ge.test(this.input.slice(this.lastTokEnd, this.start)) : e === l._else || e === l.semi || e === l.eof || e === l.parenR || e === l.arrow ? !0 : e === l.braceL ? t === D.b_stat : e === l._var || e === l._const || e === l.name ? !1 : !this.exprAllowed }; Ct.inGeneratorContext = function () { for (var e = this.context.length - 1; e >= 1; e--) { var t = this.context[e]; if (t.token === "function") return t.generator } return !1 }; Ct.updateContext = function (e) { var t, r = this.type; r.keyword && e === l.dot ? this.exprAllowed = !1 : (t = r.updateContext) ? t.call(this, e) : this.exprAllowed = r.beforeExpr }; Ct.overrideContext = function (e) { this.curContext() !== e && (this.context[this.context.length - 1] = e) }; l.parenR.updateContext = l.braceR.updateContext = function () { if (this.context.length === 1) { this.exprAllowed = !0; return } var e = this.context.pop(); e === D.b_stat && this.curContext().token === "function" && (e = this.context.pop()), this.exprAllowed = !e.isExpr }; l.braceL.updateContext = function (e) { this.context.push(this.braceIsBlock(e) ? D.b_stat : D.b_expr), this.exprAllowed = !0 }; l.dollarBraceL.updateContext = function () { this.context.push(D.b_tmpl), this.exprAllowed = !0 }; l.parenL.updateContext = function (e) { var t = e === l._if || e === l._for || e === l._with || e === l._while; this.context.push(t ? D.p_stat : D.p_expr), this.exprAllowed = !0 }; l.incDec.updateContext = function () { }; l._function.updateContext = l._class.updateContext = function (e) { e.beforeExpr && e !== l._else && !(e === l.semi && this.curContext() !== D.p_stat) && !(e === l._return && ge.test(this.input.slice(this.lastTokEnd, this.start))) && !((e === l.colon || e === l.braceL) && this.curContext() === D.b_stat) ? this.context.push(D.f_expr) : this.context.push(D.f_stat), this.exprAllowed = !1 }; l.backQuote.updateContext = function () { this.curContext() === D.q_tmpl ? this.context.pop() : this.context.push(D.q_tmpl), this.exprAllowed = !1 }; l.star.updateContext = function (e) { if (e === l._function) { var t = this.context.length - 1; this.context[t] === D.f_expr ? this.context[t] = D.f_expr_gen : this.context[t] = D.f_gen } this.exprAllowed = !0 }; l.name.updateContext = function (e) { var t = !1; this.options.ecmaVersion >= 6 && e !== l.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (t = !0), this.exprAllowed = t }; var N = W.prototype; N.checkPropClash = function (e, t, r) { if (!(this.options.ecmaVersion >= 9 && e.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (e.computed || e.method || e.shorthand))) { var i = e.key, s; switch (i.type) { case "Identifier": s = i.name; break; case "Literal": s = String(i.value); break; default: return }var n = e.kind; if (this.options.ecmaVersion >= 6) { s === "__proto__" && n === "init" && (t.proto && (r ? r.doubleProto < 0 && (r.doubleProto = i.start) : this.raiseRecoverable(i.start, "Redefinition of __proto__ property")), t.proto = !0); return } s = "$" + s; var a = t[s]; if (a) { var o; n === "init" ? o = this.strict && a.init || a.get || a.set : o = a.init || a[n], o && this.raiseRecoverable(i.start, "Redefinition of property") } else a = t[s] = { init: !1, get: !1, set: !1 }; a[n] = !0 } }; N.parseExpression = function (e, t) { var r = this.start, i = this.startLoc, s = this.parseMaybeAssign(e, t); if (this.type === l.comma) { var n = this.startNodeAt(r, i); for (n.expressions = [s]; this.eat(l.comma);)n.expressions.push(this.parseMaybeAssign(e, t)); return this.finishNode(n, "SequenceExpression") } return s }; N.parseMaybeAssign = function (e, t, r) { if (this.isContextual("yield")) { if (this.inGenerator) return this.parseYield(e); this.exprAllowed = !1 } var i = !1, s = -1, n = -1, a = -1; t ? (s = t.parenthesizedAssign, n = t.trailingComma, a = t.doubleProto, t.parenthesizedAssign = t.trailingComma = -1) : (t = new Ar, i = !0); var o = this.start, u = this.startLoc; (this.type === l.parenL || this.type === l.name) && (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = e === "await"); var c = this.parseMaybeConditional(e, t); if (r && (c = r.call(this, c, o, u)), this.type.isAssign) { var h = this.startNodeAt(o, u); return h.operator = this.value, this.type === l.eq && (c = this.toAssignable(c, !1, t)), i || (t.parenthesizedAssign = t.trailingComma = t.doubleProto = -1), t.shorthandAssign >= c.start && (t.shorthandAssign = -1), this.type === l.eq ? this.checkLValPattern(c) : this.checkLValSimple(c), h.left = c, this.next(), h.right = this.parseMaybeAssign(e), a > -1 && (t.doubleProto = a), this.finishNode(h, "AssignmentExpression") } else i && this.checkExpressionErrors(t, !0); return s > -1 && (t.parenthesizedAssign = s), n > -1 && (t.trailingComma = n), c }; N.parseMaybeConditional = function (e, t) { var r = this.start, i = this.startLoc, s = this.parseExprOps(e, t); if (this.checkExpressionErrors(t)) return s; if (this.eat(l.question)) { var n = this.startNodeAt(r, i); return n.test = s, n.consequent = this.parseMaybeAssign(), this.expect(l.colon), n.alternate = this.parseMaybeAssign(e), this.finishNode(n, "ConditionalExpression") } return s }; N.parseExprOps = function (e, t) { var r = this.start, i = this.startLoc, s = this.parseMaybeUnary(t, !1, !1, e); return this.checkExpressionErrors(t) || s.start === r && s.type === "ArrowFunctionExpression" ? s : this.parseExprOp(s, r, i, -1, e) }; N.parseExprOp = function (e, t, r, i, s) { var n = this.type.binop; if (n != null && (!s || this.type !== l._in) && n > i) { var a = this.type === l.logicalOR || this.type === l.logicalAND, o = this.type === l.coalesce; o && (n = l.logicalAND.binop); var u = this.value; this.next(); var c = this.start, h = this.startLoc, f = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, s), c, h, n, s), m = this.buildBinary(t, r, e, f, u, a || o); return (a && this.type === l.coalesce || o && (this.type === l.logicalOR || this.type === l.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(m, t, r, i, s) } return e }; N.buildBinary = function (e, t, r, i, s, n) { i.type === "PrivateIdentifier" && this.raise(i.start, "Private identifier can only be left side of binary expression"); var a = this.startNodeAt(e, t); return a.left = r, a.operator = s, a.right = i, this.finishNode(a, n ? "LogicalExpression" : "BinaryExpression") }; N.parseMaybeUnary = function (e, t, r, i) { var s = this.start, n = this.startLoc, a; if (this.isContextual("await") && this.canAwait) a = this.parseAwait(i), t = !0; else if (this.type.prefix) { var o = this.startNode(), u = this.type === l.incDec; o.operator = this.value, o.prefix = !0, this.next(), o.argument = this.parseMaybeUnary(null, !0, u, i), this.checkExpressionErrors(e, !0), u ? this.checkLValSimple(o.argument) : this.strict && o.operator === "delete" && o.argument.type === "Identifier" ? this.raiseRecoverable(o.start, "Deleting local variable in strict mode") : o.operator === "delete" && ys(o.argument) ? this.raiseRecoverable(o.start, "Private fields can not be deleted") : t = !0, a = this.finishNode(o, u ? "UpdateExpression" : "UnaryExpression") } else if (!t && this.type === l.privateId) (i || this.privateNameStack.length === 0) && this.unexpected(), a = this.parsePrivateIdent(), this.type !== l._in && this.unexpected(); else { if (a = this.parseExprSubscripts(e, i), this.checkExpressionErrors(e)) return a; for (; this.type.postfix && !this.canInsertSemicolon();) { var c = this.startNodeAt(s, n); c.operator = this.value, c.prefix = !1, c.argument = a, this.checkLValSimple(a), this.next(), a = this.finishNode(c, "UpdateExpression") } } if (!r && this.eat(l.starstar)) if (t) this.unexpected(this.lastTokStart); else return this.buildBinary(s, n, a, this.parseMaybeUnary(null, !1, !1, i), "**", !1); else return a }; function ys(e) { return e.type === "MemberExpression" && e.property.type === "PrivateIdentifier" || e.type === "ChainExpression" && ys(e.expression) } N.parseExprSubscripts = function (e, t) { var r = this.start, i = this.startLoc, s = this.parseExprAtom(e, t); if (s.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") return s; var n = this.parseSubscripts(s, r, i, !1, t); return e && n.type === "MemberExpression" && (e.parenthesizedAssign >= n.start && (e.parenthesizedAssign = -1), e.parenthesizedBind >= n.start && (e.parenthesizedBind = -1), e.trailingComma >= n.start && (e.trailingComma = -1)), n }; N.parseSubscripts = function (e, t, r, i, s) { for (var n = this.options.ecmaVersion >= 8 && e.type === "Identifier" && e.name === "async" && this.lastTokEnd === e.end && !this.canInsertSemicolon() && e.end - e.start === 5 && this.potentialArrowAt === e.start, a = !1; ;) { var o = this.parseSubscript(e, t, r, i, n, a, s); if (o.optional && (a = !0), o === e || o.type === "ArrowFunctionExpression") { if (a) { var u = this.startNodeAt(t, r); u.expression = o, o = this.finishNode(u, "ChainExpression") } return o } e = o } }; N.parseSubscript = function (e, t, r, i, s, n, a) { var o = this.options.ecmaVersion >= 11, u = o && this.eat(l.questionDot); i && u && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); var c = this.eat(l.bracketL); if (c || u && this.type !== l.parenL && this.type !== l.backQuote || this.eat(l.dot)) { var h = this.startNodeAt(t, r); h.object = e, c ? (h.property = this.parseExpression(), this.expect(l.bracketR)) : this.type === l.privateId && e.type !== "Super" ? h.property = this.parsePrivateIdent() : h.property = this.parseIdent(this.options.allowReserved !== "never"), h.computed = !!c, o && (h.optional = u), e = this.finishNode(h, "MemberExpression") } else if (!i && this.eat(l.parenL)) { var f = new Ar, m = this.yieldPos, p = this.awaitPos, g = this.awaitIdentPos; this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0; var y = this.parseExprList(l.parenR, this.options.ecmaVersion >= 8, !1, f); if (s && !u && !this.canInsertSemicolon() && this.eat(l.arrow)) return this.checkPatternErrors(f, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = m, this.awaitPos = p, this.awaitIdentPos = g, this.parseArrowExpression(this.startNodeAt(t, r), y, !0, a); this.checkExpressionErrors(f, !0), this.yieldPos = m || this.yieldPos, this.awaitPos = p || this.awaitPos, this.awaitIdentPos = g || this.awaitIdentPos; var x = this.startNodeAt(t, r); x.callee = e, x.arguments = y, o && (x.optional = u), e = this.finishNode(x, "CallExpression") } else if (this.type === l.backQuote) { (u || n) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions"); var v = this.startNodeAt(t, r); v.tag = e, v.quasi = this.parseTemplate({ isTagged: !0 }), e = this.finishNode(v, "TaggedTemplateExpression") } return e }; N.parseExprAtom = function (e, t) { this.type === l.slash && this.readRegexp(); var r, i = this.potentialArrowAt === this.start; switch (this.type) { case l._super: return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), r = this.startNode(), this.next(), this.type === l.parenL && !this.allowDirectSuper && this.raise(r.start, "super() call outside constructor of a subclass"), this.type !== l.dot && this.type !== l.bracketL && this.type !== l.parenL && this.unexpected(), this.finishNode(r, "Super"); case l._this: return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression"); case l.name: var s = this.start, n = this.startLoc, a = this.containsEsc, o = this.parseIdent(!1); if (this.options.ecmaVersion >= 8 && !a && o.name === "async" && !this.canInsertSemicolon() && this.eat(l._function)) return this.overrideContext(D.f_expr), this.parseFunction(this.startNodeAt(s, n), 0, !1, !0, t); if (i && !this.canInsertSemicolon()) { if (this.eat(l.arrow)) return this.parseArrowExpression(this.startNodeAt(s, n), [o], !1, t); if (this.options.ecmaVersion >= 8 && o.name === "async" && this.type === l.name && !a && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) return o = this.parseIdent(!1), (this.canInsertSemicolon() || !this.eat(l.arrow)) && this.unexpected(), this.parseArrowExpression(this.startNodeAt(s, n), [o], !0, t) } return o; case l.regexp: var u = this.value; return r = this.parseLiteral(u.value), r.regex = { pattern: u.pattern, flags: u.flags }, r; case l.num: case l.string: return this.parseLiteral(this.value); case l._null: case l._true: case l._false: return r = this.startNode(), r.value = this.type === l._null ? null : this.type === l._true, r.raw = this.type.keyword, this.next(), this.finishNode(r, "Literal"); case l.parenL: var c = this.start, h = this.parseParenAndDistinguishExpression(i, t); return e && (e.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(h) && (e.parenthesizedAssign = c), e.parenthesizedBind < 0 && (e.parenthesizedBind = c)), h; case l.bracketL: return r = this.startNode(), this.next(), r.elements = this.parseExprList(l.bracketR, !0, !0, e), this.finishNode(r, "ArrayExpression"); case l.braceL: return this.overrideContext(D.b_expr), this.parseObj(!1, e); case l._function: return r = this.startNode(), this.next(), this.parseFunction(r, 0); case l._class: return this.parseClass(this.startNode(), !1); case l._new: return this.parseNew(); case l.backQuote: return this.parseTemplate(); case l._import: return this.options.ecmaVersion >= 11 ? this.parseExprImport() : this.unexpected(); default: this.unexpected() } }; N.parseExprImport = function () { var e = this.startNode(); this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import"); var t = this.parseIdent(!0); switch (this.type) { case l.parenL: return this.parseDynamicImport(e); case l.dot: return e.meta = t, this.parseImportMeta(e); default: this.unexpected() } }; N.parseDynamicImport = function (e) { if (this.next(), e.source = this.parseMaybeAssign(), !this.eat(l.parenR)) { var t = this.start; this.eat(l.comma) && this.eat(l.parenR) ? this.raiseRecoverable(t, "Trailing comma is not allowed in import()") : this.unexpected(t) } return this.finishNode(e, "ImportExpression") }; N.parseImportMeta = function (e) { this.next(); var t = this.containsEsc; return e.property = this.parseIdent(!0), e.property.name !== "meta" && this.raiseRecoverable(e.property.start, "The only valid meta property for import is 'import.meta'"), t && this.raiseRecoverable(e.start, "'import.meta' must not contain escaped characters"), this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere && this.raiseRecoverable(e.start, "Cannot use 'import.meta' outside a module"), this.finishNode(e, "MetaProperty") }; N.parseLiteral = function (e) { var t = this.startNode(); return t.value = e, t.raw = this.input.slice(this.start, this.end), t.raw.charCodeAt(t.raw.length - 1) === 110 && (t.bigint = t.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(t, "Literal") }; N.parseParenExpression = function () { this.expect(l.parenL); var e = this.parseExpression(); return this.expect(l.parenR), e }; N.parseParenAndDistinguishExpression = function (e, t) { var r = this.start, i = this.startLoc, s, n = this.options.ecmaVersion >= 8; if (this.options.ecmaVersion >= 6) { this.next(); var a = this.start, o = this.startLoc, u = [], c = !0, h = !1, f = new Ar, m = this.yieldPos, p = this.awaitPos, g; for (this.yieldPos = 0, this.awaitPos = 0; this.type !== l.parenR;)if (c ? c = !1 : this.expect(l.comma), n && this.afterTrailingComma(l.parenR, !0)) { h = !0; break } else if (this.type === l.ellipsis) { g = this.start, u.push(this.parseParenItem(this.parseRestBinding())), this.type === l.comma && this.raise(this.start, "Comma is not permitted after the rest element"); break } else u.push(this.parseMaybeAssign(!1, f, this.parseParenItem)); var y = this.lastTokEnd, x = this.lastTokEndLoc; if (this.expect(l.parenR), e && !this.canInsertSemicolon() && this.eat(l.arrow)) return this.checkPatternErrors(f, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = m, this.awaitPos = p, this.parseParenArrowList(r, i, u, t); (!u.length || h) && this.unexpected(this.lastTokStart), g && this.unexpected(g), this.checkExpressionErrors(f, !0), this.yieldPos = m || this.yieldPos, this.awaitPos = p || this.awaitPos, u.length > 1 ? (s = this.startNodeAt(a, o), s.expressions = u, this.finishNodeAt(s, "SequenceExpression", y, x)) : s = u[0] } else s = this.parseParenExpression(); if (this.options.preserveParens) { var v = this.startNodeAt(r, i); return v.expression = s, this.finishNode(v, "ParenthesizedExpression") } else return s }; N.parseParenItem = function (e) { return e }; N.parseParenArrowList = function (e, t, r, i) { return this.parseArrowExpression(this.startNodeAt(e, t), r, !1, i) }; var En = []; N.parseNew = function () { this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new"); var e = this.startNode(), t = this.parseIdent(!0); if (this.options.ecmaVersion >= 6 && this.eat(l.dot)) { e.meta = t; var r = this.containsEsc; return e.property = this.parseIdent(!0), e.property.name !== "target" && this.raiseRecoverable(e.property.start, "The only valid meta property for new is 'new.target'"), r && this.raiseRecoverable(e.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(e.start, "'new.target' can only be used in functions and class static block"), this.finishNode(e, "MetaProperty") } var i = this.start, s = this.startLoc, n = this.type === l._import; return e.callee = this.parseSubscripts(this.parseExprAtom(), i, s, !0, !1), n && e.callee.type === "ImportExpression" && this.raise(i, "Cannot use new with import()"), this.eat(l.parenL) ? e.arguments = this.parseExprList(l.parenR, this.options.ecmaVersion >= 8, !1) : e.arguments = En, this.finishNode(e, "NewExpression") }; N.parseTemplateElement = function (e) {
        var t = e.isTagged, r = this.startNode(); return this.type === l.invalidTemplate ? (t || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), r.value = { raw: this.value, cooked: null }) : r.value = {
            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`), cooked: this.value
        }, this.next(), r.tail = this.type === l.backQuote, this.finishNode(r, "TemplateElement")
    }; N.parseTemplate = function (e) { e === void 0 && (e = {}); var t = e.isTagged; t === void 0 && (t = !1); var r = this.startNode(); this.next(), r.expressions = []; var i = this.parseTemplateElement({ isTagged: t }); for (r.quasis = [i]; !i.tail;)this.type === l.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(l.dollarBraceL), r.expressions.push(this.parseExpression()), this.expect(l.braceR), r.quasis.push(i = this.parseTemplateElement({ isTagged: t })); return this.next(), this.finishNode(r, "TemplateLiteral") }; N.isAsyncProp = function (e) { return !e.computed && e.key.type === "Identifier" && e.key.name === "async" && (this.type === l.name || this.type === l.num || this.type === l.string || this.type === l.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === l.star) && !ge.test(this.input.slice(this.lastTokEnd, this.start)) }; N.parseObj = function (e, t) { var r = this.startNode(), i = !0, s = {}; for (r.properties = [], this.next(); !this.eat(l.braceR);) { if (i) i = !1; else if (this.expect(l.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(l.braceR)) break; var n = this.parseProperty(e, t); e || this.checkPropClash(n, s, t), r.properties.push(n) } return this.finishNode(r, e ? "ObjectPattern" : "ObjectExpression") }; N.parseProperty = function (e, t) { var r = this.startNode(), i, s, n, a; if (this.options.ecmaVersion >= 9 && this.eat(l.ellipsis)) return e ? (r.argument = this.parseIdent(!1), this.type === l.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.finishNode(r, "RestElement")) : (this.type === l.parenL && t && (t.parenthesizedAssign < 0 && (t.parenthesizedAssign = this.start), t.parenthesizedBind < 0 && (t.parenthesizedBind = this.start)), r.argument = this.parseMaybeAssign(!1, t), this.type === l.comma && t && t.trailingComma < 0 && (t.trailingComma = this.start), this.finishNode(r, "SpreadElement")); this.options.ecmaVersion >= 6 && (r.method = !1, r.shorthand = !1, (e || t) && (n = this.start, a = this.startLoc), e || (i = this.eat(l.star))); var o = this.containsEsc; return this.parsePropertyName(r), !e && !o && this.options.ecmaVersion >= 8 && !i && this.isAsyncProp(r) ? (s = !0, i = this.options.ecmaVersion >= 9 && this.eat(l.star), this.parsePropertyName(r, t)) : s = !1, this.parsePropertyValue(r, e, i, s, n, a, t, o), this.finishNode(r, "Property") }; N.parsePropertyValue = function (e, t, r, i, s, n, a, o) { if ((r || i) && this.type === l.colon && this.unexpected(), this.eat(l.colon)) e.value = t ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, a), e.kind = "init"; else if (this.options.ecmaVersion >= 6 && this.type === l.parenL) t && this.unexpected(), e.kind = "init", e.method = !0, e.value = this.parseMethod(r, i); else if (!t && !o && this.options.ecmaVersion >= 5 && !e.computed && e.key.type === "Identifier" && (e.key.name === "get" || e.key.name === "set") && this.type !== l.comma && this.type !== l.braceR && this.type !== l.eq) { (r || i) && this.unexpected(), e.kind = e.key.name, this.parsePropertyName(e), e.value = this.parseMethod(!1); var u = e.kind === "get" ? 0 : 1; if (e.value.params.length !== u) { var c = e.value.start; e.kind === "get" ? this.raiseRecoverable(c, "getter should have no params") : this.raiseRecoverable(c, "setter should have exactly one param") } else e.kind === "set" && e.value.params[0].type === "RestElement" && this.raiseRecoverable(e.value.params[0].start, "Setter cannot use rest params") } else this.options.ecmaVersion >= 6 && !e.computed && e.key.type === "Identifier" ? ((r || i) && this.unexpected(), this.checkUnreserved(e.key), e.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = s), e.kind = "init", t ? e.value = this.parseMaybeDefault(s, n, this.copyNode(e.key)) : this.type === l.eq && a ? (a.shorthandAssign < 0 && (a.shorthandAssign = this.start), e.value = this.parseMaybeDefault(s, n, this.copyNode(e.key))) : e.value = this.copyNode(e.key), e.shorthand = !0) : this.unexpected() }; N.parsePropertyName = function (e) { if (this.options.ecmaVersion >= 6) { if (this.eat(l.bracketL)) return e.computed = !0, e.key = this.parseMaybeAssign(), this.expect(l.bracketR), e.key; e.computed = !1 } return e.key = this.type === l.num || this.type === l.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never") }; N.initFunction = function (e) { e.id = null, this.options.ecmaVersion >= 6 && (e.generator = e.expression = !1), this.options.ecmaVersion >= 8 && (e.async = !1) }; N.parseMethod = function (e, t, r) { var i = this.startNode(), s = this.yieldPos, n = this.awaitPos, a = this.awaitIdentPos; return this.initFunction(i), this.options.ecmaVersion >= 6 && (i.generator = e), this.options.ecmaVersion >= 8 && (i.async = !!t), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(di(t, i.generator) | pi | (r ? ms : 0)), this.expect(l.parenL), i.params = this.parseBindingList(l.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(i, !1, !0, !1), this.yieldPos = s, this.awaitPos = n, this.awaitIdentPos = a, this.finishNode(i, "FunctionExpression") }; N.parseArrowExpression = function (e, t, r, i) { var s = this.yieldPos, n = this.awaitPos, a = this.awaitIdentPos; return this.enterScope(di(r, !1) | fs), this.initFunction(e), this.options.ecmaVersion >= 8 && (e.async = !!r), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, e.params = this.toAssignableList(t, !0), this.parseFunctionBody(e, !0, !1, i), this.yieldPos = s, this.awaitPos = n, this.awaitIdentPos = a, this.finishNode(e, "ArrowFunctionExpression") }; N.parseFunctionBody = function (e, t, r, i) { var s = t && this.type !== l.braceL, n = this.strict, a = !1; if (s) e.body = this.parseMaybeAssign(i), e.expression = !0, this.checkParams(e, !1); else { var o = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(e.params); (!n || o) && (a = this.strictDirective(this.end), a && o && this.raiseRecoverable(e.start, "Illegal 'use strict' directive in function with non-simple parameter list")); var u = this.labels; this.labels = [], a && (this.strict = !0), this.checkParams(e, !n && !a && !t && !r && this.isSimpleParamList(e.params)), this.strict && e.id && this.checkLValSimple(e.id, xs), e.body = this.parseBlock(!1, void 0, a && !n), e.expression = !1, this.adaptDirectivePrologue(e.body.body), this.labels = u } this.exitScope() }; N.isSimpleParamList = function (e) { for (var t = 0, r = e; t < r.length; t += 1) { var i = r[t]; if (i.type !== "Identifier") return !1 } return !0 }; N.checkParams = function (e, t) { for (var r = Object.create(null), i = 0, s = e.params; i < s.length; i += 1) { var n = s[i]; this.checkLValInnerPattern(n, gi, t ? null : r) } }; N.parseExprList = function (e, t, r, i) { for (var s = [], n = !0; !this.eat(e);) { if (n) n = !1; else if (this.expect(l.comma), t && this.afterTrailingComma(e)) break; var a = void 0; r && this.type === l.comma ? a = null : this.type === l.ellipsis ? (a = this.parseSpread(i), i && this.type === l.comma && i.trailingComma < 0 && (i.trailingComma = this.start)) : a = this.parseMaybeAssign(!1, i), s.push(a) } return s }; N.checkUnreserved = function (e) { var t = e.start, r = e.end, i = e.name; if (this.inGenerator && i === "yield" && this.raiseRecoverable(t, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && i === "await" && this.raiseRecoverable(t, "Cannot use 'await' as identifier inside an async function"), this.currentThisScope().inClassFieldInit && i === "arguments" && this.raiseRecoverable(t, "Cannot use 'arguments' in class field initializer"), this.inClassStaticBlock && (i === "arguments" || i === "await") && this.raise(t, "Cannot use " + i + " in class static initialization block"), this.keywords.test(i) && this.raise(t, "Unexpected keyword '" + i + "'"), !(this.options.ecmaVersion < 6 && this.input.slice(t, r).indexOf("\\") !== -1)) { var s = this.strict ? this.reservedWordsStrict : this.reservedWords; s.test(i) && (!this.inAsync && i === "await" && this.raiseRecoverable(t, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(t, "The keyword '" + i + "' is reserved")) } }; N.parseIdent = function (e, t) { var r = this.startNode(); return this.type === l.name ? r.name = this.value : this.type.keyword ? (r.name = this.type.keyword, (r.name === "class" || r.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop()) : this.unexpected(), this.next(!!e), this.finishNode(r, "Identifier"), e || (this.checkUnreserved(r), r.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = r.start)), r }; N.parsePrivateIdent = function () { var e = this.startNode(); return this.type === l.privateId ? e.name = this.value : this.unexpected(), this.next(), this.finishNode(e, "PrivateIdentifier"), this.privateNameStack.length === 0 ? this.raise(e.start, "Private field '#" + e.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(e), e }; N.parseYield = function (e) { this.yieldPos || (this.yieldPos = this.start); var t = this.startNode(); return this.next(), this.type === l.semi || this.canInsertSemicolon() || this.type !== l.star && !this.type.startsExpr ? (t.delegate = !1, t.argument = null) : (t.delegate = this.eat(l.star), t.argument = this.parseMaybeAssign(e)), this.finishNode(t, "YieldExpression") }; N.parseAwait = function (e) { this.awaitPos || (this.awaitPos = this.start); var t = this.startNode(); return this.next(), t.argument = this.parseMaybeUnary(null, !0, !1, e), this.finishNode(t, "AwaitExpression") }; var Cr = W.prototype; Cr.raise = function (e, t) { var r = cs(this.input, e); t += " (" + r.line + ":" + r.column + ")"; var i = new SyntaxError(t); throw i.pos = e, i.loc = r, i.raisedAt = this.pos, i }; Cr.raiseRecoverable = Cr.raise; Cr.curPosition = function () { if (this.options.locations) return new Dt(this.curLine, this.pos - this.lineStart) }; var Ke = W.prototype, Cn = function (t) { this.flags = t, this.var = [], this.lexical = [], this.functions = [], this.inClassFieldInit = !1 }; Ke.enterScope = function (e) { this.scopeStack.push(new Cn(e)) }; Ke.exitScope = function () { this.scopeStack.pop() }; Ke.treatFunctionsAsVarInScope = function (e) { return e.flags & Et || !this.inModule && e.flags & Bt }; Ke.declareName = function (e, t, r) { var i = !1; if (t === Fe) { var s = this.currentScope(); i = s.lexical.indexOf(e) > -1 || s.functions.indexOf(e) > -1 || s.var.indexOf(e) > -1, s.lexical.push(e), this.inModule && s.flags & Bt && delete this.undefinedExports[e] } else if (t === gs) { var n = this.currentScope(); n.lexical.push(e) } else if (t === ds) { var a = this.currentScope(); this.treatFunctionsAsVar ? i = a.lexical.indexOf(e) > -1 : i = a.lexical.indexOf(e) > -1 || a.var.indexOf(e) > -1, a.functions.push(e) } else for (var o = this.scopeStack.length - 1; o >= 0; --o) { var u = this.scopeStack[o]; if (u.lexical.indexOf(e) > -1 && !(u.flags & ps && u.lexical[0] === e) || !this.treatFunctionsAsVarInScope(u) && u.functions.indexOf(e) > -1) { i = !0; break } if (u.var.push(e), this.inModule && u.flags & Bt && delete this.undefinedExports[e], u.flags & mi) break } i && this.raiseRecoverable(r, "Identifier '" + e + "' has already been declared") }; Ke.checkLocalExport = function (e) { this.scopeStack[0].lexical.indexOf(e.name) === -1 && this.scopeStack[0].var.indexOf(e.name) === -1 && (this.undefinedExports[e.name] = e) }; Ke.currentScope = function () { return this.scopeStack[this.scopeStack.length - 1] }; Ke.currentVarScope = function () { for (var e = this.scopeStack.length - 1; ; e--) { var t = this.scopeStack[e]; if (t.flags & mi) return t } }; Ke.currentThisScope = function () { for (var e = this.scopeStack.length - 1; ; e--) { var t = this.scopeStack[e]; if (t.flags & mi && !(t.flags & fs)) return t } }; var Pr = function (t, r, i) { this.type = "", this.start = r, this.end = 0, t.options.locations && (this.loc = new kr(t, i)), t.options.directSourceFile && (this.sourceFile = t.options.directSourceFile), t.options.ranges && (this.range = [r, 0]) }, $t = W.prototype; $t.startNode = function () { return new Pr(this, this.start, this.startLoc) }; $t.startNodeAt = function (e, t) { return new Pr(this, e, t) }; function vs(e, t, r, i) { return e.type = t, e.end = r, this.options.locations && (e.loc.end = i), this.options.ranges && (e.range[1] = r), e } $t.finishNode = function (e, t) { return vs.call(this, e, t, this.lastTokEnd, this.lastTokEndLoc) }; $t.finishNodeAt = function (e, t, r, i) { return vs.call(this, e, t, r, i) }; $t.copyNode = function (e) { var t = new Pr(this, e.start, this.startLoc); for (var r in e) t[r] = e[r]; return t }; var ws = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", _s = ws + " Extended_Pictographic", Ss = _s, Es = Ss + " EBase EComp EMod EPres ExtPict", kn = Es, An = { 9: ws, 10: _s, 11: Ss, 12: Es, 13: kn }, is = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", Cs = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", ks = Cs + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", As = ks + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", Ps = As + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", Pn = Ps + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", On = { 9: Cs, 10: ks, 11: As, 12: Ps, 13: Pn }, Os = {}; function In(e) { var t = Os[e] = { binary: lt(An[e] + " " + is), nonBinary: { General_Category: lt(is), Script: lt(On[e]) } }; t.nonBinary.Script_Extensions = t.nonBinary.Script, t.nonBinary.gc = t.nonBinary.General_Category, t.nonBinary.sc = t.nonBinary.Script, t.nonBinary.scx = t.nonBinary.Script_Extensions } for (_r = 0, oi = [9, 10, 11, 12, 13]; _r < oi.length; _r += 1)ss = oi[_r], In(ss); var ss, _r, oi, E = W.prototype, Re = function (t) { this.parser = t, this.validFlags = "gim" + (t.options.ecmaVersion >= 6 ? "uy" : "") + (t.options.ecmaVersion >= 9 ? "s" : "") + (t.options.ecmaVersion >= 13 ? "d" : ""), this.unicodeProperties = Os[t.options.ecmaVersion >= 13 ? 13 : t.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [] }; Re.prototype.reset = function (t, r, i) { var s = i.indexOf("u") !== -1; this.start = t | 0, this.source = r + "", this.flags = i, this.switchU = s && this.parser.options.ecmaVersion >= 6, this.switchN = s && this.parser.options.ecmaVersion >= 9 }; Re.prototype.raise = function (t) { this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + t) }; Re.prototype.at = function (t, r) { r === void 0 && (r = !1); var i = this.source, s = i.length; if (t >= s) return -1; var n = i.charCodeAt(t); if (!(r || this.switchU) || n <= 55295 || n >= 57344 || t + 1 >= s) return n; var a = i.charCodeAt(t + 1); return a >= 56320 && a <= 57343 ? (n << 10) + a - 56613888 : n }; Re.prototype.nextIndex = function (t, r) { r === void 0 && (r = !1); var i = this.source, s = i.length; if (t >= s) return s; var n = i.charCodeAt(t), a; return !(r || this.switchU) || n <= 55295 || n >= 57344 || t + 1 >= s || (a = i.charCodeAt(t + 1)) < 56320 || a > 57343 ? t + 1 : t + 2 }; Re.prototype.current = function (t) { return t === void 0 && (t = !1), this.at(this.pos, t) }; Re.prototype.lookahead = function (t) { return t === void 0 && (t = !1), this.at(this.nextIndex(this.pos, t), t) }; Re.prototype.advance = function (t) { t === void 0 && (t = !1), this.pos = this.nextIndex(this.pos, t) }; Re.prototype.eat = function (t, r) { return r === void 0 && (r = !1), this.current(r) === t ? (this.advance(r), !0) : !1 }; E.validateRegExpFlags = function (e) { for (var t = e.validFlags, r = e.flags, i = 0; i < r.length; i++) { var s = r.charAt(i); t.indexOf(s) === -1 && this.raise(e.start, "Invalid regular expression flag"), r.indexOf(s, i + 1) > -1 && this.raise(e.start, "Duplicate regular expression flag") } }; E.validateRegExpPattern = function (e) { this.regexp_pattern(e), !e.switchN && this.options.ecmaVersion >= 9 && e.groupNames.length > 0 && (e.switchN = !0, this.regexp_pattern(e)) }; E.regexp_pattern = function (e) { e.pos = 0, e.lastIntValue = 0, e.lastStringValue = "", e.lastAssertionIsQuantifiable = !1, e.numCapturingParens = 0, e.maxBackReference = 0, e.groupNames.length = 0, e.backReferenceNames.length = 0, this.regexp_disjunction(e), e.pos !== e.source.length && (e.eat(41) && e.raise("Unmatched ')'"), (e.eat(93) || e.eat(125)) && e.raise("Lone quantifier brackets")), e.maxBackReference > e.numCapturingParens && e.raise("Invalid escape"); for (var t = 0, r = e.backReferenceNames; t < r.length; t += 1) { var i = r[t]; e.groupNames.indexOf(i) === -1 && e.raise("Invalid named capture referenced") } }; E.regexp_disjunction = function (e) { for (this.regexp_alternative(e); e.eat(124);)this.regexp_alternative(e); this.regexp_eatQuantifier(e, !0) && e.raise("Nothing to repeat"), e.eat(123) && e.raise("Lone quantifier brackets") }; E.regexp_alternative = function (e) { for (; e.pos < e.source.length && this.regexp_eatTerm(e);); }; E.regexp_eatTerm = function (e) { return this.regexp_eatAssertion(e) ? (e.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(e) && e.switchU && e.raise("Invalid quantifier"), !0) : (e.switchU ? this.regexp_eatAtom(e) : this.regexp_eatExtendedAtom(e)) ? (this.regexp_eatQuantifier(e), !0) : !1 }; E.regexp_eatAssertion = function (e) { var t = e.pos; if (e.lastAssertionIsQuantifiable = !1, e.eat(94) || e.eat(36)) return !0; if (e.eat(92)) { if (e.eat(66) || e.eat(98)) return !0; e.pos = t } if (e.eat(40) && e.eat(63)) { var r = !1; if (this.options.ecmaVersion >= 9 && (r = e.eat(60)), e.eat(61) || e.eat(33)) return this.regexp_disjunction(e), e.eat(41) || e.raise("Unterminated group"), e.lastAssertionIsQuantifiable = !r, !0 } return e.pos = t, !1 }; E.regexp_eatQuantifier = function (e, t) { return t === void 0 && (t = !1), this.regexp_eatQuantifierPrefix(e, t) ? (e.eat(63), !0) : !1 }; E.regexp_eatQuantifierPrefix = function (e, t) { return e.eat(42) || e.eat(43) || e.eat(63) || this.regexp_eatBracedQuantifier(e, t) }; E.regexp_eatBracedQuantifier = function (e, t) { var r = e.pos; if (e.eat(123)) { var i = 0, s = -1; if (this.regexp_eatDecimalDigits(e) && (i = e.lastIntValue, e.eat(44) && this.regexp_eatDecimalDigits(e) && (s = e.lastIntValue), e.eat(125))) return s !== -1 && s < i && !t && e.raise("numbers out of order in {} quantifier"), !0; e.switchU && !t && e.raise("Incomplete quantifier"), e.pos = r } return !1 }; E.regexp_eatAtom = function (e) { return this.regexp_eatPatternCharacters(e) || e.eat(46) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e) }; E.regexp_eatReverseSolidusAtomEscape = function (e) { var t = e.pos; if (e.eat(92)) { if (this.regexp_eatAtomEscape(e)) return !0; e.pos = t } return !1 }; E.regexp_eatUncapturingGroup = function (e) { var t = e.pos; if (e.eat(40)) { if (e.eat(63) && e.eat(58)) { if (this.regexp_disjunction(e), e.eat(41)) return !0; e.raise("Unterminated group") } e.pos = t } return !1 }; E.regexp_eatCapturingGroup = function (e) { if (e.eat(40)) { if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(e) : e.current() === 63 && e.raise("Invalid group"), this.regexp_disjunction(e), e.eat(41)) return e.numCapturingParens += 1, !0; e.raise("Unterminated group") } return !1 }; E.regexp_eatExtendedAtom = function (e) { return e.eat(46) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e) || this.regexp_eatInvalidBracedQuantifier(e) || this.regexp_eatExtendedPatternCharacter(e) }; E.regexp_eatInvalidBracedQuantifier = function (e) { return this.regexp_eatBracedQuantifier(e, !0) && e.raise("Nothing to repeat"), !1 }; E.regexp_eatSyntaxCharacter = function (e) { var t = e.current(); return Is(t) ? (e.lastIntValue = t, e.advance(), !0) : !1 }; function Is(e) { return e === 36 || e >= 40 && e <= 43 || e === 46 || e === 63 || e >= 91 && e <= 94 || e >= 123 && e <= 125 } E.regexp_eatPatternCharacters = function (e) { for (var t = e.pos, r = 0; (r = e.current()) !== -1 && !Is(r);)e.advance(); return e.pos !== t }; E.regexp_eatExtendedPatternCharacter = function (e) { var t = e.current(); return t !== -1 && t !== 36 && !(t >= 40 && t <= 43) && t !== 46 && t !== 63 && t !== 91 && t !== 94 && t !== 124 ? (e.advance(), !0) : !1 }; E.regexp_groupSpecifier = function (e) { if (e.eat(63)) { if (this.regexp_eatGroupName(e)) { e.groupNames.indexOf(e.lastStringValue) !== -1 && e.raise("Duplicate capture group name"), e.groupNames.push(e.lastStringValue); return } e.raise("Invalid group") } }; E.regexp_eatGroupName = function (e) { if (e.lastStringValue = "", e.eat(60)) { if (this.regexp_eatRegExpIdentifierName(e) && e.eat(62)) return !0; e.raise("Invalid capture group name") } return !1 }; E.regexp_eatRegExpIdentifierName = function (e) { if (e.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(e)) { for (e.lastStringValue += Ge(e.lastIntValue); this.regexp_eatRegExpIdentifierPart(e);)e.lastStringValue += Ge(e.lastIntValue); return !0 } return !1 }; E.regexp_eatRegExpIdentifierStart = function (e) { var t = e.pos, r = this.options.ecmaVersion >= 11, i = e.current(r); return e.advance(r), i === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e, r) && (i = e.lastIntValue), Nn(i) ? (e.lastIntValue = i, !0) : (e.pos = t, !1) }; function Nn(e) { return Le(e, !0) || e === 36 || e === 95 } E.regexp_eatRegExpIdentifierPart = function (e) { var t = e.pos, r = this.options.ecmaVersion >= 11, i = e.current(r); return e.advance(r), i === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e, r) && (i = e.lastIntValue), Tn(i) ? (e.lastIntValue = i, !0) : (e.pos = t, !1) }; function Tn(e) { return _t(e, !0) || e === 36 || e === 95 || e === 8204 || e === 8205 } E.regexp_eatAtomEscape = function (e) { return this.regexp_eatBackReference(e) || this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e) || e.switchN && this.regexp_eatKGroupName(e) ? !0 : (e.switchU && (e.current() === 99 && e.raise("Invalid unicode escape"), e.raise("Invalid escape")), !1) }; E.regexp_eatBackReference = function (e) { var t = e.pos; if (this.regexp_eatDecimalEscape(e)) { var r = e.lastIntValue; if (e.switchU) return r > e.maxBackReference && (e.maxBackReference = r), !0; if (r <= e.numCapturingParens) return !0; e.pos = t } return !1 }; E.regexp_eatKGroupName = function (e) { if (e.eat(107)) { if (this.regexp_eatGroupName(e)) return e.backReferenceNames.push(e.lastStringValue), !0; e.raise("Invalid named reference") } return !1 }; E.regexp_eatCharacterEscape = function (e) { return this.regexp_eatControlEscape(e) || this.regexp_eatCControlLetter(e) || this.regexp_eatZero(e) || this.regexp_eatHexEscapeSequence(e) || this.regexp_eatRegExpUnicodeEscapeSequence(e, !1) || !e.switchU && this.regexp_eatLegacyOctalEscapeSequence(e) || this.regexp_eatIdentityEscape(e) }; E.regexp_eatCControlLetter = function (e) { var t = e.pos; if (e.eat(99)) { if (this.regexp_eatControlLetter(e)) return !0; e.pos = t } return !1 }; E.regexp_eatZero = function (e) { return e.current() === 48 && !Or(e.lookahead()) ? (e.lastIntValue = 0, e.advance(), !0) : !1 }; E.regexp_eatControlEscape = function (e) { var t = e.current(); return t === 116 ? (e.lastIntValue = 9, e.advance(), !0) : t === 110 ? (e.lastIntValue = 10, e.advance(), !0) : t === 118 ? (e.lastIntValue = 11, e.advance(), !0) : t === 102 ? (e.lastIntValue = 12, e.advance(), !0) : t === 114 ? (e.lastIntValue = 13, e.advance(), !0) : !1 }; E.regexp_eatControlLetter = function (e) { var t = e.current(); return Ns(t) ? (e.lastIntValue = t % 32, e.advance(), !0) : !1 }; function Ns(e) { return e >= 65 && e <= 90 || e >= 97 && e <= 122 } E.regexp_eatRegExpUnicodeEscapeSequence = function (e, t) { t === void 0 && (t = !1); var r = e.pos, i = t || e.switchU; if (e.eat(117)) { if (this.regexp_eatFixedHexDigits(e, 4)) { var s = e.lastIntValue; if (i && s >= 55296 && s <= 56319) { var n = e.pos; if (e.eat(92) && e.eat(117) && this.regexp_eatFixedHexDigits(e, 4)) { var a = e.lastIntValue; if (a >= 56320 && a <= 57343) return e.lastIntValue = (s - 55296) * 1024 + (a - 56320) + 65536, !0 } e.pos = n, e.lastIntValue = s } return !0 } if (i && e.eat(123) && this.regexp_eatHexDigits(e) && e.eat(125) && Fn(e.lastIntValue)) return !0; i && e.raise("Invalid unicode escape"), e.pos = r } return !1 }; function Fn(e) { return e >= 0 && e <= 1114111 } E.regexp_eatIdentityEscape = function (e) { if (e.switchU) return this.regexp_eatSyntaxCharacter(e) ? !0 : e.eat(47) ? (e.lastIntValue = 47, !0) : !1; var t = e.current(); return t !== 99 && (!e.switchN || t !== 107) ? (e.lastIntValue = t, e.advance(), !0) : !1 }; E.regexp_eatDecimalEscape = function (e) { e.lastIntValue = 0; var t = e.current(); if (t >= 49 && t <= 57) { do e.lastIntValue = 10 * e.lastIntValue + (t - 48), e.advance(); while ((t = e.current()) >= 48 && t <= 57); return !0 } return !1 }; E.regexp_eatCharacterClassEscape = function (e) { var t = e.current(); if (Ln(t)) return e.lastIntValue = -1, e.advance(), !0; if (e.switchU && this.options.ecmaVersion >= 9 && (t === 80 || t === 112)) { if (e.lastIntValue = -1, e.advance(), e.eat(123) && this.regexp_eatUnicodePropertyValueExpression(e) && e.eat(125)) return !0; e.raise("Invalid property name") } return !1 }; function Ln(e) { return e === 100 || e === 68 || e === 115 || e === 83 || e === 119 || e === 87 } E.regexp_eatUnicodePropertyValueExpression = function (e) { var t = e.pos; if (this.regexp_eatUnicodePropertyName(e) && e.eat(61)) { var r = e.lastStringValue; if (this.regexp_eatUnicodePropertyValue(e)) { var i = e.lastStringValue; return this.regexp_validateUnicodePropertyNameAndValue(e, r, i), !0 } } if (e.pos = t, this.regexp_eatLoneUnicodePropertyNameOrValue(e)) { var s = e.lastStringValue; return this.regexp_validateUnicodePropertyNameOrValue(e, s), !0 } return !1 }; E.regexp_validateUnicodePropertyNameAndValue = function (e, t, r) { jt(e.unicodeProperties.nonBinary, t) || e.raise("Invalid property name"), e.unicodeProperties.nonBinary[t].test(r) || e.raise("Invalid property value") }; E.regexp_validateUnicodePropertyNameOrValue = function (e, t) { e.unicodeProperties.binary.test(t) || e.raise("Invalid property name") }; E.regexp_eatUnicodePropertyName = function (e) { var t = 0; for (e.lastStringValue = ""; Ts(t = e.current());)e.lastStringValue += Ge(t), e.advance(); return e.lastStringValue !== "" }; function Ts(e) { return Ns(e) || e === 95 } E.regexp_eatUnicodePropertyValue = function (e) { var t = 0; for (e.lastStringValue = ""; Rn(t = e.current());)e.lastStringValue += Ge(t), e.advance(); return e.lastStringValue !== "" }; function Rn(e) { return Ts(e) || Or(e) } E.regexp_eatLoneUnicodePropertyNameOrValue = function (e) { return this.regexp_eatUnicodePropertyValue(e) }; E.regexp_eatCharacterClass = function (e) { if (e.eat(91)) { if (e.eat(94), this.regexp_classRanges(e), e.eat(93)) return !0; e.raise("Unterminated character class") } return !1 }; E.regexp_classRanges = function (e) { for (; this.regexp_eatClassAtom(e);) { var t = e.lastIntValue; if (e.eat(45) && this.regexp_eatClassAtom(e)) { var r = e.lastIntValue; e.switchU && (t === -1 || r === -1) && e.raise("Invalid character class"), t !== -1 && r !== -1 && t > r && e.raise("Range out of order in character class") } } }; E.regexp_eatClassAtom = function (e) { var t = e.pos; if (e.eat(92)) { if (this.regexp_eatClassEscape(e)) return !0; if (e.switchU) { var r = e.current(); (r === 99 || Rs(r)) && e.raise("Invalid class escape"), e.raise("Invalid escape") } e.pos = t } var i = e.current(); return i !== 93 ? (e.lastIntValue = i, e.advance(), !0) : !1 }; E.regexp_eatClassEscape = function (e) { var t = e.pos; if (e.eat(98)) return e.lastIntValue = 8, !0; if (e.switchU && e.eat(45)) return e.lastIntValue = 45, !0; if (!e.switchU && e.eat(99)) { if (this.regexp_eatClassControlLetter(e)) return !0; e.pos = t } return this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e) }; E.regexp_eatClassControlLetter = function (e) { var t = e.current(); return Or(t) || t === 95 ? (e.lastIntValue = t % 32, e.advance(), !0) : !1 }; E.regexp_eatHexEscapeSequence = function (e) { var t = e.pos; if (e.eat(120)) { if (this.regexp_eatFixedHexDigits(e, 2)) return !0; e.switchU && e.raise("Invalid escape"), e.pos = t } return !1 }; E.regexp_eatDecimalDigits = function (e) { var t = e.pos, r = 0; for (e.lastIntValue = 0; Or(r = e.current());)e.lastIntValue = 10 * e.lastIntValue + (r - 48), e.advance(); return e.pos !== t }; function Or(e) { return e >= 48 && e <= 57 } E.regexp_eatHexDigits = function (e) { var t = e.pos, r = 0; for (e.lastIntValue = 0; Fs(r = e.current());)e.lastIntValue = 16 * e.lastIntValue + Ls(r), e.advance(); return e.pos !== t }; function Fs(e) { return e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102 } function Ls(e) { return e >= 65 && e <= 70 ? 10 + (e - 65) : e >= 97 && e <= 102 ? 10 + (e - 97) : e - 48 } E.regexp_eatLegacyOctalEscapeSequence = function (e) { if (this.regexp_eatOctalDigit(e)) { var t = e.lastIntValue; if (this.regexp_eatOctalDigit(e)) { var r = e.lastIntValue; t <= 3 && this.regexp_eatOctalDigit(e) ? e.lastIntValue = t * 64 + r * 8 + e.lastIntValue : e.lastIntValue = t * 8 + r } else e.lastIntValue = t; return !0 } return !1 }; E.regexp_eatOctalDigit = function (e) { var t = e.current(); return Rs(t) ? (e.lastIntValue = t - 48, e.advance(), !0) : (e.lastIntValue = 0, !1) }; function Rs(e) { return e >= 48 && e <= 55 } E.regexp_eatFixedHexDigits = function (e, t) { var r = e.pos; e.lastIntValue = 0; for (var i = 0; i < t; ++i) { var s = e.current(); if (!Fs(s)) return e.pos = r, !1; e.lastIntValue = 16 * e.lastIntValue + Ls(s), e.advance() } return !0 }; var bi = function (t) { this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, t.options.locations && (this.loc = new kr(t, t.startLoc, t.endLoc)), t.options.ranges && (this.range = [t.start, t.end]) }, T = W.prototype; T.next = function (e) { !e && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new bi(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken() }; T.getToken = function () { return this.next(), new bi(this) }; typeof Symbol < "u" && (T[Symbol.iterator] = function () { var e = this; return { next: function () { var t = e.getToken(); return { done: t.type === l.eof, value: t } } } }); T.nextToken = function () { var e = this.curContext(); if ((!e || !e.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length) return this.finishToken(l.eof); if (e.override) return e.override(this); this.readToken(this.fullCharCodeAtPos()) }; T.readToken = function (e) { return Le(e, this.options.ecmaVersion >= 6) || e === 92 ? this.readWord() : this.getTokenFromCode(e) }; T.fullCharCodeAtPos = function () { var e = this.input.charCodeAt(this.pos); if (e <= 55295 || e >= 56320) return e; var t = this.input.charCodeAt(this.pos + 1); return t <= 56319 || t >= 57344 ? e : (e << 10) + t - 56613888 }; T.skipBlockComment = function () { var e = this.options.onComment && this.curPosition(), t = this.pos, r = this.input.indexOf("*/", this.pos += 2); if (r === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = r + 2, this.options.locations) for (var i = void 0, s = t; (i = os(this.input, s, this.pos)) > -1;)++this.curLine, s = this.lineStart = i; this.options.onComment && this.options.onComment(!0, this.input.slice(t + 2, r), t, this.pos, e, this.curPosition()) }; T.skipLineComment = function (e) { for (var t = this.pos, r = this.options.onComment && this.curPosition(), i = this.input.charCodeAt(this.pos += e); this.pos < this.input.length && !St(i);)i = this.input.charCodeAt(++this.pos); this.options.onComment && this.options.onComment(!1, this.input.slice(t + e, this.pos), t, this.pos, r, this.curPosition()) }; T.skipSpace = function () { e: for (; this.pos < this.input.length;) { var e = this.input.charCodeAt(this.pos); switch (e) { case 32: case 160: ++this.pos; break; case 13: this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos; case 10: case 8232: case 8233: ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos); break; case 47: switch (this.input.charCodeAt(this.pos + 1)) { case 42: this.skipBlockComment(); break; case 47: this.skipLineComment(2); break; default: break e }break; default: if (e > 8 && e < 14 || e >= 5760 && us.test(String.fromCharCode(e))) ++this.pos; else break e } } }; T.finishToken = function (e, t) { this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition()); var r = this.type; this.type = e, this.value = t, this.updateContext(r) }; T.readToken_dot = function () { var e = this.input.charCodeAt(this.pos + 1); if (e >= 48 && e <= 57) return this.readNumber(!0); var t = this.input.charCodeAt(this.pos + 2); return this.options.ecmaVersion >= 6 && e === 46 && t === 46 ? (this.pos += 3, this.finishToken(l.ellipsis)) : (++this.pos, this.finishToken(l.dot)) }; T.readToken_slash = function () { var e = this.input.charCodeAt(this.pos + 1); return this.exprAllowed ? (++this.pos, this.readRegexp()) : e === 61 ? this.finishOp(l.assign, 2) : this.finishOp(l.slash, 1) }; T.readToken_mult_modulo_exp = function (e) { var t = this.input.charCodeAt(this.pos + 1), r = 1, i = e === 42 ? l.star : l.modulo; return this.options.ecmaVersion >= 7 && e === 42 && t === 42 && (++r, i = l.starstar, t = this.input.charCodeAt(this.pos + 2)), t === 61 ? this.finishOp(l.assign, r + 1) : this.finishOp(i, r) }; T.readToken_pipe_amp = function (e) { var t = this.input.charCodeAt(this.pos + 1); if (t === e) { if (this.options.ecmaVersion >= 12) { var r = this.input.charCodeAt(this.pos + 2); if (r === 61) return this.finishOp(l.assign, 3) } return this.finishOp(e === 124 ? l.logicalOR : l.logicalAND, 2) } return t === 61 ? this.finishOp(l.assign, 2) : this.finishOp(e === 124 ? l.bitwiseOR : l.bitwiseAND, 1) }; T.readToken_caret = function () { var e = this.input.charCodeAt(this.pos + 1); return e === 61 ? this.finishOp(l.assign, 2) : this.finishOp(l.bitwiseXOR, 1) }; T.readToken_plus_min = function (e) { var t = this.input.charCodeAt(this.pos + 1); return t === e ? t === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || ge.test(this.input.slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(l.incDec, 2) : t === 61 ? this.finishOp(l.assign, 2) : this.finishOp(l.plusMin, 1) }; T.readToken_lt_gt = function (e) { var t = this.input.charCodeAt(this.pos + 1), r = 1; return t === e ? (r = e === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + r) === 61 ? this.finishOp(l.assign, r + 1) : this.finishOp(l.bitShift, r)) : t === 33 && e === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (t === 61 && (r = 2), this.finishOp(l.relational, r)) }; T.readToken_eq_excl = function (e) { var t = this.input.charCodeAt(this.pos + 1); return t === 61 ? this.finishOp(l.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : e === 61 && t === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(l.arrow)) : this.finishOp(e === 61 ? l.eq : l.prefix, 1) }; T.readToken_question = function () { var e = this.options.ecmaVersion; if (e >= 11) { var t = this.input.charCodeAt(this.pos + 1); if (t === 46) { var r = this.input.charCodeAt(this.pos + 2); if (r < 48 || r > 57) return this.finishOp(l.questionDot, 2) } if (t === 63) { if (e >= 12) { var i = this.input.charCodeAt(this.pos + 2); if (i === 61) return this.finishOp(l.assign, 3) } return this.finishOp(l.coalesce, 2) } } return this.finishOp(l.question, 1) }; T.readToken_numberSign = function () { var e = this.options.ecmaVersion, t = 35; if (e >= 13 && (++this.pos, t = this.fullCharCodeAtPos(), Le(t, !0) || t === 92)) return this.finishToken(l.privateId, this.readWord1()); this.raise(this.pos, "Unexpected character '" + Ge(t) + "'") }; T.getTokenFromCode = function (e) { switch (e) { case 46: return this.readToken_dot(); case 40: return ++this.pos, this.finishToken(l.parenL); case 41: return ++this.pos, this.finishToken(l.parenR); case 59: return ++this.pos, this.finishToken(l.semi); case 44: return ++this.pos, this.finishToken(l.comma); case 91: return ++this.pos, this.finishToken(l.bracketL); case 93: return ++this.pos, this.finishToken(l.bracketR); case 123: return ++this.pos, this.finishToken(l.braceL); case 125: return ++this.pos, this.finishToken(l.braceR); case 58: return ++this.pos, this.finishToken(l.colon); case 96: if (this.options.ecmaVersion < 6) break; return ++this.pos, this.finishToken(l.backQuote); case 48: var t = this.input.charCodeAt(this.pos + 1); if (t === 120 || t === 88) return this.readRadixNumber(16); if (this.options.ecmaVersion >= 6) { if (t === 111 || t === 79) return this.readRadixNumber(8); if (t === 98 || t === 66) return this.readRadixNumber(2) } case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: return this.readNumber(!1); case 34: case 39: return this.readString(e); case 47: return this.readToken_slash(); case 37: case 42: return this.readToken_mult_modulo_exp(e); case 124: case 38: return this.readToken_pipe_amp(e); case 94: return this.readToken_caret(); case 43: case 45: return this.readToken_plus_min(e); case 60: case 62: return this.readToken_lt_gt(e); case 61: case 33: return this.readToken_eq_excl(e); case 63: return this.readToken_question(); case 126: return this.finishOp(l.prefix, 1); case 35: return this.readToken_numberSign() }this.raise(this.pos, "Unexpected character '" + Ge(e) + "'") }; T.finishOp = function (e, t) { var r = this.input.slice(this.pos, this.pos + t); return this.pos += t, this.finishToken(e, r) }; T.readRegexp = function () { for (var e, t, r = this.pos; ;) { this.pos >= this.input.length && this.raise(r, "Unterminated regular expression"); var i = this.input.charAt(this.pos); if (ge.test(i) && this.raise(r, "Unterminated regular expression"), e) e = !1; else { if (i === "[") t = !0; else if (i === "]" && t) t = !1; else if (i === "/" && !t) break; e = i === "\\" } ++this.pos } var s = this.input.slice(r, this.pos); ++this.pos; var n = this.pos, a = this.readWord1(); this.containsEsc && this.unexpected(n); var o = this.regexpState || (this.regexpState = new Re(this)); o.reset(r, s, a), this.validateRegExpFlags(o), this.validateRegExpPattern(o); var u = null; try { u = new RegExp(s, a) } catch { } return this.finishToken(l.regexp, { pattern: s, flags: a, value: u }) }; T.readInt = function (e, t, r) { for (var i = this.options.ecmaVersion >= 12 && t === void 0, s = r && this.input.charCodeAt(this.pos) === 48, n = this.pos, a = 0, o = 0, u = 0, c = t ?? 1 / 0; u < c; ++u, ++this.pos) { var h = this.input.charCodeAt(this.pos), f = void 0; if (i && h === 95) { s && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), o === 95 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), u === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), o = h; continue } if (h >= 97 ? f = h - 97 + 10 : h >= 65 ? f = h - 65 + 10 : h >= 48 && h <= 57 ? f = h - 48 : f = 1 / 0, f >= e) break; o = h, a = a * e + f } return i && o === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === n || t != null && this.pos - n !== t ? null : a }; function Mn(e, t) { return t ? parseInt(e, 8) : parseFloat(e.replace(/_/g, "")) } function Ms(e) { return typeof BigInt != "function" ? null : BigInt(e.replace(/_/g, "")) } T.readRadixNumber = function (e) { var t = this.pos; this.pos += 2; var r = this.readInt(e); return r == null && this.raise(this.start + 2, "Expected number in radix " + e), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (r = Ms(this.input.slice(t, this.pos)), ++this.pos) : Le(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(l.num, r) }; T.readNumber = function (e) { var t = this.pos; !e && this.readInt(10, void 0, !0) === null && this.raise(t, "Invalid number"); var r = this.pos - t >= 2 && this.input.charCodeAt(t) === 48; r && this.strict && this.raise(t, "Invalid number"); var i = this.input.charCodeAt(this.pos); if (!r && !e && this.options.ecmaVersion >= 11 && i === 110) { var s = Ms(this.input.slice(t, this.pos)); return ++this.pos, Le(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(l.num, s) } r && /[89]/.test(this.input.slice(t, this.pos)) && (r = !1), i === 46 && !r && (++this.pos, this.readInt(10), i = this.input.charCodeAt(this.pos)), (i === 69 || i === 101) && !r && (i = this.input.charCodeAt(++this.pos), (i === 43 || i === 45) && ++this.pos, this.readInt(10) === null && this.raise(t, "Invalid number")), Le(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"); var n = Mn(this.input.slice(t, this.pos), r); return this.finishToken(l.num, n) }; T.readCodePoint = function () { var e = this.input.charCodeAt(this.pos), t; if (e === 123) { this.options.ecmaVersion < 6 && this.unexpected(); var r = ++this.pos; t = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, t > 1114111 && this.invalidStringToken(r, "Code point out of bounds") } else t = this.readHexChar(4); return t }; T.readString = function (e) { for (var t = "", r = ++this.pos; ;) { this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant"); var i = this.input.charCodeAt(this.pos); if (i === e) break; i === 92 ? (t += this.input.slice(r, this.pos), t += this.readEscapedChar(!1), r = this.pos) : i === 8232 || i === 8233 ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (St(i) && this.raise(this.start, "Unterminated string constant"), ++this.pos) } return t += this.input.slice(r, this.pos++), this.finishToken(l.string, t) }; var Vs = {}; T.tryReadTemplateToken = function () { this.inTemplateElement = !0; try { this.readTmplToken() } catch (e) { if (e === Vs) this.readInvalidTemplateToken(); else throw e } this.inTemplateElement = !1 }; T.invalidStringToken = function (e, t) { if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw Vs; this.raise(e, t) }; T.readTmplToken = function () {
        for (var e = "", t = this.pos; ;) {
            this.pos >= this.input.length && this.raise(this.start, "Unterminated template"); var r = this.input.charCodeAt(this.pos); if (r === 96 || r === 36 && this.input.charCodeAt(this.pos + 1) === 123) return this.pos === this.start && (this.type === l.template || this.type === l.invalidTemplate) ? r === 36 ? (this.pos += 2, this.finishToken(l.dollarBraceL)) : (++this.pos, this.finishToken(l.backQuote)) : (e += this.input.slice(t, this.pos), this.finishToken(l.template, e)); if (r === 92) e += this.input.slice(t, this.pos), e += this.readEscapedChar(!0), t = this.pos; else if (St(r)) {
                switch (e += this.input.slice(t, this.pos), ++this.pos, r) {
                    case 13: this.input.charCodeAt(this.pos) === 10 && ++this.pos; case 10: e += `
`; break; default: e += String.fromCharCode(r); break
                }this.options.locations && (++this.curLine, this.lineStart = this.pos), t = this.pos
            } else ++this.pos
        }
    }; T.readInvalidTemplateToken = function () { for (; this.pos < this.input.length; this.pos++)switch (this.input[this.pos]) { case "\\": ++this.pos; break; case "$": if (this.input[this.pos + 1] !== "{") break; case "`": return this.finishToken(l.invalidTemplate, this.input.slice(this.start, this.pos)) }this.raise(this.start, "Unterminated template") }; T.readEscapedChar = function (e) {
        var t = this.input.charCodeAt(++this.pos); switch (++this.pos, t) {
            case 110: return `
`; case 114: return "\r"; case 120: return String.fromCharCode(this.readHexChar(2)); case 117: return Ge(this.readCodePoint()); case 116: return "	"; case 98: return "\b"; case 118: return "\v"; case 102: return "\f"; case 13: this.input.charCodeAt(this.pos) === 10 && ++this.pos; case 10: return this.options.locations && (this.lineStart = this.pos, ++this.curLine), ""; case 56: case 57: if (this.strict && this.invalidStringToken(this.pos - 1, "Invalid escape sequence"), e) { var r = this.pos - 1; return this.invalidStringToken(r, "Invalid escape sequence in template string"), null } default: if (t >= 48 && t <= 55) { var i = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], s = parseInt(i, 8); return s > 255 && (i = i.slice(0, -1), s = parseInt(i, 8)), this.pos += i.length - 1, t = this.input.charCodeAt(this.pos), (i !== "0" || t === 56 || t === 57) && (this.strict || e) && this.invalidStringToken(this.pos - 1 - i.length, e ? "Octal literal in template string" : "Octal literal in strict mode"), String.fromCharCode(s) } return St(t) ? "" : String.fromCharCode(t)
        }
    }; T.readHexChar = function (e) { var t = this.pos, r = this.readInt(16, e); return r === null && this.invalidStringToken(t, "Bad character escape sequence"), r }; T.readWord1 = function () { this.containsEsc = !1; for (var e = "", t = !0, r = this.pos, i = this.options.ecmaVersion >= 6; this.pos < this.input.length;) { var s = this.fullCharCodeAtPos(); if (_t(s, i)) this.pos += s <= 65535 ? 1 : 2; else if (s === 92) { this.containsEsc = !0, e += this.input.slice(r, this.pos); var n = this.pos; this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos; var a = this.readCodePoint(); (t ? Le : _t)(a, i) || this.invalidStringToken(n, "Invalid Unicode escape"), e += Ge(a), r = this.pos } else break; t = !1 } return e + this.input.slice(r, this.pos) }; T.readWord = function () { var e = this.readWord1(), t = l.name; return this.keywords.test(e) && (t = hi[e]), this.finishToken(t, e) }; var Vn = "8.7.1"; W.acorn = { Parser: W, version: Vn, defaultOptions: li, Position: Dt, SourceLocation: kr, getLineInfo: cs, Node: Pr, TokenType: L, tokTypes: l, keywordTypes: hi, TokContext: _e, tokContexts: D, isIdentifierChar: _t, isIdentifierStart: Le, Token: bi, isNewLine: St, lineBreak: ge, lineBreakG: mn, nonASCIIwhitespace: us }; var ii = W.extend(function (e) { let t = !1, r = !1, i = !1; return class extends e { parseFunction(s, n, a, o, u) { return this.type.label === "**" && (s.isSubscriptFunction = !0, this.next()), super.parseFunction(s, n, a, o, u) } isClassElementNameStart() { return this.type.label === "**" && (t = !0, this.next()), super.isClassElementNameStart() } isAsyncProp(s) { return this.type.label === "**" && (t = !0, this.next()), super.isAsyncProp(s) } eat(s) { return (i && s.label === ":" || (i || r) && s.label === "*") && this.type.label === "**" ? (t = !0, this.next(), !1) : super.eat(s) } parseProperty(s, n) { i = !0; let a = super.parseProperty(s, n); return i = !1, t && (a.value.isSubscriptFunction = !0, t = !1), a } parseClassElement(s) { r = !0; let n = super.parseClassElement(s); return r = !1, t && (n.value.isSubscriptFunction = !0, t = !1), n } } }); var Ds = e => class extends si(e) { static get subscriptParams() { return { globalsAutoObserve: ["document"] } } static expose(t, r) { let i = b(t, "oohtml", "subscript", "instances"), s = r.name; return s || (s = [...i.keys()].filter(n => Y(n)).length), i.set(s, r), r } static implementMethod(t, r) { let i = super.implementMethod(t, r); return this.expose(r, i) } static implementScript(t, r) { let i = (t.textContent || "").trim(); return this.expose(r, V.call(r, i, { compilerParams: this.compilerParams, runtimeParams: this.runtimeParams })) } static doConnectedCallback(t) { if (typeof WebQit > "u" || !WebQit.Observer) return; let r = b(t, "oohtml", "subscript", "instances"), i = (s, n, a = []) => { r.forEach(o => o.thread(...s.map(u => a.concat(u.path)))) }; (this.subscriptParams.globalsAutoObserve || []).forEach(s => { WebQit.Observer.observe(globalThis[s], n => i(n, null, [s]), { subtree: !0, diff: !0, tags: [t, "subscript-element", s], unique: !0 }) }), WebQit.Observer.observe(t, s => i(s, null, ["this"]), { subtree: !0, diff: !0, tags: [t, "subscript-element", "this"], unique: !0 }) } static doDisconnectedCallback(t) { typeof WebQit > "u" || !WebQit.Observer || ((this.subscriptParams.globalsAutoObserve || []).forEach(r => { WebQit.Observer.unobserve(globalThis[r], null, null, { subtree: !0, tags: [t, "subscript-element", r] }) }), WebQit.Observer.unobserve(t, null, null, { subtree: !0, tags: [t, "subscript-element", "this"] })) } connectedCallback() { this.constructor.doConnectedCallback(this), super.connectedCallback && super.connectedCallback() } disconnectedCallback() { this.constructor.doDisconnectedCallback(this), super.disconnectedCallback && super.disconnectedCallback() } get subscript() { return b(this, "oohtml", "subscript", "instances") } }; function Ir(e = {}) { let t = ie.call(this); if (e.onDomReady) { t.DOM.ready(() => { Ir.call(this, { ...e, onDomReady: !1 }) }); return } let r = t.DOM.mutations, i = Ee.call(this, { selectors: { script: 'script[type="subscript"]' }, api: { bind: "bind", unbind: "unbind" }, script: {} }, e.params), s = a => class extends Ds(a) { static get compilerParams() { return e.compilerParams || {} } static get runtimeParams() { return e.runtimeParams || {} } }, n = s(); r.onPresent(i.get("selectors.script"), a => { let o = a.parentNode; if (!o) return; let u = b(o, "oohtml", "subscript").get("script-tags"); if (u || (u = new WeakSet, b(o, "oohtml", "subscript").set("script-tags", u)), u.has(a)) return; n.implementScript(a, o)(), n.doConnectedCallback(o), u.add(a); let c = r.onRemoved(o, () => { n.doDisconnectedCallback(o), u.delete(a), c.disconnect() }, { ignoreTransients: !0 }) }), t.OOHTML || (t.OOHTML = {}), t.OOHTML.SubscriptElement = s } function yi(e = {}) { let t = ie.call(this); t.OOHTML || (t.OOHTML = {}, t.Observer = U, gr.call(this, e.HTMLModules || {}), xr.call(this, e.HTMLImports || {}), br.call(this, e.NamespacedHTML || {}), yr.call(this, e.StateAPI || {}), Ir.call(this, e.Subscript || {})) } yi.call(window);
})();
//# sourceMappingURL=main.js.map
